///
/// Tailboard Models and Data Structures for Crew Management System
///
/// This file contains comprehensive data models for the tailboard feature of the
/// crew management application. The tailboard serves as a centralized dashboard
/// for crew collaboration, job matching, activity tracking, and communication.
///
/// The tailboard integrates with Firebase Firestore for persistence and supports
/// real-time updates for collaborative features between crew members.
///

import 'package:cloud_firestore/cloud_firestore.dart';

/// Enumeration defining the various sources through which job suggestions
/// can be generated and presented to crew members on the tailboard.
///
/// This helps track how jobs are discovered and allows different algorithms
/// for different discovery methods.
enum JobSuggestionSource {
  /// Job suggested by the AI matching algorithm based on crew member profiles,
  /// skills, location preferences, and job requirements analysis.
  aiMatch,

  /// Job shared directly by a crew member who found it relevant for others
  /// in their crew network.
  memberShare,

  /// Job automatically shared with the crew based on predefined criteria
  /// such as job type, pay rate, or geographic location matching.
  autoShare,

  /// Job discovered through a saved search alert system where crew members
  /// can configure automated job searches based on their preferences.
  savedSearch,
}

/// Enumeration defining the different types of activities that can occur
/// within a crew and be tracked on the activity stream.
///
/// These activities help crew members stay informed about important events
/// and changes within their crew network.
enum ActivityType {
  /// A new member has joined the crew, typically after accepting an invitation
  /// or being added by a crew administrator.
  memberJoined,

  /// A member has left the crew, either voluntarily or by crew admin action
  memberLeft,

  /// A job opportunity has been shared within the crew for discussion
  /// or consideration by other members.
  jobShared,

  /// A crew member has applied to a job, either from crew-shared opportunities
  /// or from the AI-matched job feed.
  jobApplied,

  /// An important announcement has been posted to the crew's tailboard
  announcementPosted,

  /// A significant milestone has been reached by the crew, such as completing
  /// a major project, reaching member count goals, or achieving quality metrics.
  milestoneReached,
}

/// Enumeration defining the types of reactions crew members can add to
/// posts and other interactive content on the tailboard.
///
/// Reactions allow crew members to engage with content without necessarily
/// writing full comments, providing quick feedback mechanisms.
enum ReactionType {
  /// Standard positive reaction indicating approval or agreement
  like,

  /// Strong positive reaction expressing enthusiasm or strong support
  love,

  /// Celebration reaction for accomplishments, milestones, or good news
  celebrate,

  /// Upward thumb indicating approval or acceptance
  thumbsUp,

  /// Downward thumb indicating disapproval or concern
  thumbsDown,
}

/// Represents a job suggestion made to a crew member through the tailboard system.
///
/// The SuggestedJob class encapsulates job recommendations generated by various AI
/// algorithms and user interactions. It tracks the job reference, matching details,
/// member engagement metrics, and the source of the suggestion.
///
/// This class is used within the crew's job feed to present personalized job
/// opportunities based on member profiles, skills, and preferences. Relationships:
/// - References Job entities by ID
/// - Contained within Tailboard.jobFeed list
/// - Updated when members view, apply, or save jobs
class SuggestedJob {
  /// Unique identifier referencing the primary Job entity that contains
  /// job details like description, requirements, pay, and location.
  final String jobId;

  /// AI-calculated match percentage (0-100) indicating how well this job
  /// aligns with the crew member's profile, skills, and preferences.
  final int matchScore;

  /// List of human-readable explanations why this job was suggested,
  /// such as "Matches your electrical skills", "In your preferred area",
  /// or "Pay rate meets your minimum requirements".
  final List<String> matchReasons;

  /// List of crew member IDs who have viewed this job suggestion.
  /// Used for analytics and to prevent duplicate notifications.
  final List<String> viewedByMemberIds;

  /// List of crew member IDs who have applied to this job through
  /// the tailboard system. Tracks conversion success.
  final List<String> appliedMemberIds;

  /// List of crew member IDs who have saved this job for later consideration.
  /// Indicates strong interest but not immediate application.
  final List<String> savedByMemberIds;

  /// Timestamp when this job suggestion was first presented to the crew.
  /// Used for sorting and determining suggestion freshness.
  final DateTime suggestedAt;

  /// The method or algorithm that generated this job suggestion.
  /// Helps track which discovery methods are most effective.
  final JobSuggestionSource source;

  /// Creates a new SuggestedJob instance with all required properties.
  ///
  /// This constructor is used when creating job suggestions programmatically,
  /// such as when the AI matching algorithm identifies potential opportunities
  /// for crew members based on their profiles and preferences.
  ///
  /// Parameters:
  /// - [jobId]: Unique identifier of the job being suggested
  /// - [matchScore]: AI-calculated relevance score (0-100)
  /// - [matchReasons]: List of human-readable explanations for the match
  /// - [viewedByMemberIds]: Initially empty list, populated as members interact
  /// - [appliedMemberIds]: Initially empty list, populated when members apply
  /// - [savedByMemberIds]: Initially empty list, populated when members save
  /// - [suggestedAt]: Timestamp of when the suggestion was generated
  /// - [source]: Method used to generate this suggestion
  SuggestedJob({
    required this.jobId,
    required this.matchScore,
    required this.matchReasons,
    required this.viewedByMemberIds,
    required this.appliedMemberIds,
    required this.savedByMemberIds,
    required this.suggestedAt,
    required this.source,
  });

  /// Deserializes a SuggestedJob instance from a map structure.
  ///
  /// This factory constructor is used when loading job suggestions from storage
  /// (such as Firestore documents or JSON files). It safely handles missing data
  /// by providing default values to prevent runtime errors.
  ///
  /// Parameters:
  /// - [map]: Map containing the serialized job suggestion data
  ///
  /// Returns a fully constructed SuggestedJob instance with default fallbacks
  /// for any missing fields. This ensures data integrity during deserialization.
  factory SuggestedJob.fromMap(Map<String, dynamic> map) {
    return SuggestedJob(
      jobId: map['jobId'] ?? '',
      matchScore: map['matchScore'] ?? 0,
      matchReasons: List<String>.from(map['matchReasons'] ?? []),
      viewedByMemberIds: List<String>.from(map['viewedByMemberIds'] ?? []),
      appliedMemberIds: List<String>.from(map['appliedMemberIds'] ?? []),
      savedByMemberIds: List<String>.from(map['savedByMemberIds'] ?? []),
      suggestedAt: map['suggestedAt'] != null
          ? DateTime.parse(map['suggestedAt'] as String)
          : DateTime.now(),
      source: JobSuggestionSource.values.firstWhere(
        (s) => s.toString().split('.').last == (map['source'] ?? 'aiMatch'),
        orElse: () => JobSuggestionSource.aiMatch,
      ),
    );
  }

  /// Serializes this SuggestedJob instance into a map structure.
  ///
  /// This method converts the object into a format suitable for storage or
  /// transmission, such as JSON or Firestore documents. All datetime objects
  /// are converted to ISO 8601 strings, and enums are converted to string
  /// representations of their values (without the enum class prefix).
  ///
  /// Returns a Map<String, dynamic> containing all the job suggestion data,
  /// ready to be stored in a database or sent over a network.
  Map<String, dynamic> toMap() {
    return {
      'jobId': jobId,
      'matchScore': matchScore,
      'matchReasons': matchReasons,
      'viewedByMemberIds': viewedByMemberIds,
      'appliedMemberIds': appliedMemberIds,
      'savedByMemberIds': savedByMemberIds,
      'suggestedAt': suggestedAt.toIso8601String(),
      'source': source.toString().split('.').last,
    };
  }

  /// Creates a new SuggestedJob instance with selectively updated properties.
  ///
  /// This method provides immutable state updates for job suggestion objects.
  /// Any non-null parameter will override the corresponding property, while
  /// null parameters preserve the original values. This pattern supports
  /// functional programming approaches and ensures thread safety.
  ///
  /// Parameters:
  /// - [jobId]: New job reference ID, or null to keep existing
  /// - [matchScore]: Updated match percentage, or null to keep existing
  /// - [matchReasons]: New match explanation list, or null to keep existing
  /// - [viewedByMemberIds]: Updated viewer list, or null to keep existing
  /// - [appliedMemberIds]: Updated application list, or null to keep existing
  /// - [savedByMemberIds]: Updated saved list, or null to keep existing
  /// - [suggestedAt]: New suggestion timestamp, or null to keep existing
  /// - [source]: Updated suggestion source, or null to keep existing
  ///
  /// Returns a new SuggestedJob instance with the specified modifications,
  /// preserving immutability of the original object.
  SuggestedJob copyWith({
    String? jobId,
    int? matchScore,
    List<String>? matchReasons,
    List<String>? viewedByMemberIds,
    List<String>? appliedMemberIds,
    List<String>? savedByMemberIds,
    DateTime? suggestedAt,
    JobSuggestionSource? source,
  }) {
    return SuggestedJob(
      jobId: jobId ?? this.jobId,
      matchScore: matchScore ?? this.matchScore,
      matchReasons: matchReasons ?? this.matchReasons,
      viewedByMemberIds: viewedByMemberIds ?? this.viewedByMemberIds,
      appliedMemberIds: appliedMemberIds ?? this.appliedMemberIds,
      savedByMemberIds: savedByMemberIds ?? this.savedByMemberIds,
      suggestedAt: suggestedAt ?? this.suggestedAt,
      source: source ?? this.source,
    );
  }

  /// Marks this job suggestion as viewed by a specific crew member.
  ///
  /// This helper method records member engagement with job suggestions by
  /// adding their ID to the viewedByMemberIds list. Prevents duplicate entries
  /// by checking if the member has already viewed this suggestion.
  ///
  /// Used by the UI when a member clicks on or opens a job suggestion,
  /// enabling analytics and preventing redundant notifications.
  ///
  /// Parameters:
  /// - [memberId]: Unique identifier of the crew member who viewed the job
  ///
  /// Returns an updated SuggestedJob instance with the member added to
  /// the viewed list, or the same instance if already viewed.
  SuggestedJob markAsViewed(String memberId) {
    if (viewedByMemberIds.contains(memberId)) return this;

    return copyWith(
      viewedByMemberIds: [...viewedByMemberIds, memberId],
    );
  }

  /// Marks this job suggestion as applied to by a specific crew member.
  ///
  /// Records successful conversions when crew members apply to suggested jobs
  /// through the tailboard system. This tracks the effectiveness of job
  /// matching algorithms and helps measure crew engagement with suggestions.
  ///
  /// Parameters:
  /// - [memberId]: Unique identifier of the crew member who applied
  ///
  /// Returns an updated SuggestedJob instance with the member added to
  /// the applied list, or the same instance if already applied.
  SuggestedJob markAsApplied(String memberId) {
    if (appliedMemberIds.contains(memberId)) return this;

    return copyWith(
      appliedMemberIds: [...appliedMemberIds, memberId],
    );
  }

  /// Marks this job suggestion as saved by a specific crew member.
  ///
  /// Indicates strong interest in a job suggestion when a member saves it
  /// for later consideration. This differentiates between casual viewing
  /// and serious intent to pursue the opportunity.
  ///
  /// Parameters:
  /// - [memberId]: Unique identifier of the crew member who saved the job
  ///
  /// Returns an updated SuggestedJob instance with the member added to
  /// the saved list, or the same instance if already saved.
  SuggestedJob markAsSaved(String memberId) {
    if (savedByMemberIds.contains(memberId)) return this;

    return copyWith(
      savedByMemberIds: [...savedByMemberIds, memberId],
    );
  }
}

class ActivityItem {
  final String id;
  final String actorId;                // User who performed action
  final ActivityType type;             // Type of activity
  final Map<String, dynamic> data;     // Activity-specific data
  final DateTime timestamp;             // When it happened
  final List<String> readByMemberIds;  // Who has seen it

  ActivityItem({
    required this.id,
    required this.actorId,
    required this.type,
    required this.data,
    required this.timestamp,
    required this.readByMemberIds,
  });

  factory ActivityItem.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return ActivityItem(
      id: doc.id,
      actorId: data['actorId'] ?? '',
      type: ActivityType.values.firstWhere(
        (t) => t.toString().split('.').last == (data['type'] ?? 'memberJoined'),
        orElse: () => ActivityType.memberJoined,
      ),
      data: Map<String, dynamic>.from(data['data'] ?? {}),
      timestamp: (data['timestamp'] as Timestamp?)?.toDate() ?? DateTime.now(),
      readByMemberIds: List<String>.from(data['readByMemberIds'] ?? []),
    );
  }

  factory ActivityItem.fromMap(Map<String, dynamic> map) {
    return ActivityItem(
      id: map['id'] ?? '',
      actorId: map['actorId'] ?? '',
      type: ActivityType.values.firstWhere(
        (t) => t.toString().split('.').last == (map['type'] ?? 'memberJoined'),
        orElse: () => ActivityType.memberJoined,
      ),
      data: Map<String, dynamic>.from(map['data'] ?? {}),
      timestamp: map['timestamp'] != null
          ? DateTime.parse(map['timestamp'] as String)
          : DateTime.now(),
      readByMemberIds: List<String>.from(map['readByMemberIds'] ?? []),
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'actorId': actorId,
      'type': type.toString().split('.').last,
      'data': data,
      'timestamp': Timestamp.fromDate(timestamp),
      'readByMemberIds': readByMemberIds,
    };
  }

  ActivityItem copyWith({
    String? id,
    String? actorId,
    ActivityType? type,
    Map<String, dynamic>? data,
    DateTime? timestamp,
    List<String>? readByMemberIds,
  }) {
    return ActivityItem(
      id: id ?? this.id,
      actorId: actorId ?? this.actorId,
      type: type ?? this.type,
      data: data ?? this.data,
      timestamp: timestamp ?? this.timestamp,
      readByMemberIds: readByMemberIds ?? this.readByMemberIds,
    );
  }

  // Helper method to mark as read by member
  ActivityItem markAsRead(String memberId) {
    if (readByMemberIds.contains(memberId)) return this;
    
    return copyWith(
      readByMemberIds: [...readByMemberIds, memberId],
    );
  }

  // Helper method to check if member has read this activity
  bool isReadBy(String memberId) {
    return readByMemberIds.contains(memberId);
  }
}

class Comment {
  final String id;
  final String authorId;
  final String content;
  final DateTime postedAt;
  final DateTime? editedAt;

  Comment({
    required this.id,
    required this.authorId,
    required this.content,
    required this.postedAt,
    this.editedAt,
  });

  factory Comment.fromMap(Map<String, dynamic> map) {
    return Comment(
      id: map['id'] ?? '',
      authorId: map['authorId'] ?? '',
      content: map['content'] ?? '',
      postedAt: map['postedAt'] != null
          ? DateTime.parse(map['postedAt'] as String)
          : DateTime.now(),
      editedAt: map['editedAt'] != null
          ? DateTime.parse(map['editedAt'] as String)
          : null,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'authorId': authorId,
      'content': content,
      'postedAt': postedAt.toIso8601String(),
      'editedAt': editedAt?.toIso8601String(),
    };
  }

  Comment copyWith({
    String? id,
    String? authorId,
    String? content,
    DateTime? postedAt,
    DateTime? editedAt,
  }) {
    return Comment(
      id: id ?? this.id,
      authorId: authorId ?? this.authorId,
      content: content ?? this.content,
      postedAt: postedAt ?? this.postedAt,
      editedAt: editedAt ?? this.editedAt,
    );
  }
}

class TailboardPost {
  final String id;
  final String authorId;               // Who posted
  final String content;                // Post text
  final List<String> attachmentUrls;   // Images, documents
  final bool isPinned;                 // Sticky post
  final Map<String, ReactionType> reactions; // Member reactions
  final List<Comment> comments;        // Threaded comments
  final DateTime postedAt;
  final DateTime? editedAt;            // If edited

  TailboardPost({
    required this.id,
    required this.authorId,
    required this.content,
    required this.attachmentUrls,
    required this.isPinned,
    required this.reactions,
    required this.comments,
    required this.postedAt,
    this.editedAt,
  });

  factory TailboardPost.fromMap(Map<String, dynamic> map) {
    return TailboardPost(
      id: map['id'] ?? '',
      authorId: map['authorId'] ?? '',
      content: map['content'] ?? '',
      attachmentUrls: List<String>.from(map['attachmentUrls'] ?? []),
      isPinned: map['isPinned'] ?? false,
      reactions: Map<String, ReactionType>.fromEntries(
        (map['reactions'] as Map<String, dynamic>?)?.entries.map(
              (entry) => MapEntry(
                entry.key,
                ReactionType.values.firstWhere(
                  (r) => r.toString().split('.').last == entry.value,
                  orElse: () => ReactionType.like,
                ),
              ),
            ) ??
            {},
      ),
      comments: List<Comment>.from(
        (map['comments'] as List<dynamic>? ?? [])
            .map((item) => Comment.fromMap(item as Map<String, dynamic>)),
      ),
      postedAt: map['postedAt'] != null
          ? DateTime.parse(map['postedAt'] as String)
          : DateTime.now(),
      editedAt: map['editedAt'] != null
          ? DateTime.parse(map['editedAt'] as String)
          : null,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'authorId': authorId,
      'content': content,
      'attachmentUrls': attachmentUrls,
      'isPinned': isPinned,
      'reactions': reactions.map(
        (key, value) => MapEntry(key, value.toString().split('.').last),
      ),
      'comments': comments.map((comment) => comment.toMap()).toList(),
      'postedAt': postedAt.toIso8601String(),
      'editedAt': editedAt?.toIso8601String(),
    };
  }

  TailboardPost copyWith({
    String? id,
    String? authorId,
    String? content,
    List<String>? attachmentUrls,
    bool? isPinned,
    Map<String, ReactionType>? reactions,
    List<Comment>? comments,
    DateTime? postedAt,
    DateTime? editedAt,
  }) {
    return TailboardPost(
      id: id ?? this.id,
      authorId: authorId ?? this.authorId,
      content: content ?? this.content,
      attachmentUrls: attachmentUrls ?? this.attachmentUrls,
      isPinned: isPinned ?? this.isPinned,
      reactions: reactions ?? this.reactions,
      comments: comments ?? this.comments,
      postedAt: postedAt ?? this.postedAt,
      editedAt: editedAt ?? this.editedAt,
    );
  }

  // Helper method to add a reaction
  TailboardPost addReaction(String memberId, ReactionType reaction) {
    final updatedReactions = Map<String, ReactionType>.from(reactions);
    updatedReactions[memberId] = reaction;
    
    return copyWith(reactions: updatedReactions);
  }

  // Helper method to remove a reaction
  TailboardPost removeReaction(String memberId) {
    final updatedReactions = Map<String, ReactionType>.from(reactions);
    updatedReactions.remove(memberId);
    
    return copyWith(reactions: updatedReactions);
  }

  // Helper method to add a comment
  TailboardPost addComment(Comment comment) {
    return copyWith(
      comments: [...comments, comment],
    );
  }

  // Helper method to pin/unpin post
  TailboardPost togglePin() {
    return copyWith(isPinned: !isPinned);
  }
}

class CrewCalendar {
  final Map<String, dynamic> events; // Calendar events data
  final DateTime lastUpdated;

  CrewCalendar({
    required this.events,
    required this.lastUpdated,
  });

  factory CrewCalendar.fromMap(Map<String, dynamic> map) {
    return CrewCalendar(
      events: Map<String, dynamic>.from(map['events'] ?? {}),
      lastUpdated: map['lastUpdated'] != null
          ? DateTime.parse(map['lastUpdated'] as String)
          : DateTime.now(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'events': events,
      'lastUpdated': lastUpdated.toIso8601String(),
    };
  }
}

class TailboardAnalytics {
  final int totalPosts;
  final int totalActivities;
  final int totalSuggestedJobs;
  final double engagementRate;
  final DateTime lastCalculated;

  TailboardAnalytics({
    required this.totalPosts,
    required this.totalActivities,
    required this.totalSuggestedJobs,
    required this.engagementRate,
    required this.lastCalculated,
  });

  factory TailboardAnalytics.fromMap(Map<String, dynamic> map) {
    return TailboardAnalytics(
      totalPosts: map['totalPosts'] ?? 0,
      totalActivities: map['totalActivities'] ?? 0,
      totalSuggestedJobs: map['totalSuggestedJobs'] ?? 0,
      engagementRate: (map['engagementRate'] ?? 0.0).toDouble(),
      lastCalculated: map['lastCalculated'] != null
          ? DateTime.parse(map['lastCalculated'] as String)
          : DateTime.now(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'totalPosts': totalPosts,
      'totalActivities': totalActivities,
      'totalSuggestedJobs': totalSuggestedJobs,
      'engagementRate': engagementRate,
      'lastCalculated': lastCalculated.toIso8601String(),
    };
  }
}

class Tailboard {
  final String crewId;
  final List<SuggestedJob> jobFeed;    // AI-matched jobs
  final List<ActivityItem> activityStream; // Recent crew activities
  final List<TailboardPost> posts;     // Announcements and discussions
  final List<String> recentMessages;  // Latest message previews
  final CrewCalendar calendar;         // Shared availability
  final TailboardAnalytics analytics;  // Performance metrics
  final DateTime lastUpdated;          // For sync optimization

  Tailboard({
    required this.crewId,
    required this.jobFeed,
    required this.activityStream,
    required this.posts,
    required this.recentMessages,
    required this.calendar,
    required this.analytics,
    required this.lastUpdated,
  });

  factory Tailboard.fromMap(Map<String, dynamic> map) {
    return Tailboard(
      crewId: map['crewId'] ?? '',
      jobFeed: List<SuggestedJob>.from(
        (map['jobFeed'] as List<dynamic>? ?? [])
            .map((item) => SuggestedJob.fromMap(item as Map<String, dynamic>)),
      ),
      activityStream: List<ActivityItem>.from(
        (map['activityStream'] as List<dynamic>? ?? [])
            .map((item) => ActivityItem.fromMap(item as Map<String, dynamic>)),
      ),
      posts: List<TailboardPost>.from(
        (map['posts'] as List<dynamic>? ?? [])
            .map((item) => TailboardPost.fromMap(item as Map<String, dynamic>)),
      ),
      recentMessages: List<String>.from(map['recentMessages'] ?? []),
      calendar: CrewCalendar.fromMap(map['calendar'] ?? {}),
      analytics: TailboardAnalytics.fromMap(map['analytics'] ?? {}),
      lastUpdated: map['lastUpdated'] != null
          ? DateTime.parse(map['lastUpdated'] as String)
          : DateTime.now(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'crewId': crewId,
      'jobFeed': jobFeed.map((job) => job.toMap()).toList(),
      'activityStream': activityStream.map((activity) => activity.toFirestore()).toList(),
      'posts': posts.map((post) => post.toMap()).toList(),
      'recentMessages': recentMessages,
      'calendar': calendar.toMap(),
      'analytics': analytics.toMap(),
      'lastUpdated': lastUpdated.toIso8601String(),
    };
  }

  Tailboard copyWith({
    String? crewId,
    List<SuggestedJob>? jobFeed,
    List<ActivityItem>? activityStream,
    List<TailboardPost>? posts,
    List<String>? recentMessages,
    CrewCalendar? calendar,
    TailboardAnalytics? analytics,
    DateTime? lastUpdated,
  }) {
    return Tailboard(
      crewId: crewId ?? this.crewId,
      jobFeed: jobFeed ?? this.jobFeed,
      activityStream: activityStream ?? this.activityStream,
      posts: posts ?? this.posts,
      recentMessages: recentMessages ?? this.recentMessages,
      calendar: calendar ?? this.calendar,
      analytics: analytics ?? this.analytics,
      lastUpdated: lastUpdated ?? this.lastUpdated,
    );
  }
}
