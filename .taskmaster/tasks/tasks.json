{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Flutter Project with Firebase Integration",
        "description": "Initialize the Flutter project with the required dependencies and configure Firebase services for the application.",
        "details": "1. Create a new Flutter project using Flutter CLI:\n```bash\nflutter create journeyman_jobs --org com.ibew.journeymanjobs\n```\n2. Configure project for both iOS and Android platforms\n3. Add required dependencies to pubspec.yaml:\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  firebase_core: ^2.15.0\n  firebase_auth: ^4.7.2\n  cloud_firestore: ^4.8.4\n  firebase_storage: ^11.2.5\n  google_sign_in: ^6.1.4\n  sign_in_with_apple: ^5.0.0\n  provider: ^6.0.5\n  go_router: ^10.0.0\n  flutter_animate: ^4.2.0\n  cached_network_image: ^3.2.3\n  shared_preferences: ^2.2.0\n  badges: ^3.1.1\n  google_generative_ai: ^0.4.7\n```\n4. Setup Firebase project in Firebase Console\n5. Download and add google-services.json and GoogleService-Info.plist to respective platform folders\n6. Initialize Firebase in main.dart:\n```dart\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await Firebase.initializeApp(\n    options: DefaultFirebaseOptions.currentPlatform,\n  );\n  runApp(MyApp());\n}\n```\n7. Configure Firebase Security Rules for Firestore and Storage",
        "testStrategy": "1. Verify project builds successfully on both iOS and Android\n2. Test Firebase connection by running a simple read/write operation\n3. Validate all dependencies resolve without conflicts\n4. Ensure Firebase initialization completes successfully\n5. Verify security rules are properly applied using Firebase Emulator Suite",
        "priority": "high",
        "dependencies": [],
        "status": "completed",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Flutter Project and Configure Dependencies",
            "description": "Set up a new Flutter project and add all necessary dependencies for Firebase integration.",
            "dependencies": [],
            "details": "1. Create a new Flutter project using Flutter CLI\n2. Update pubspec.yaml to include firebase_core, firebase_auth, cloud_firestore, and other required Firebase packages\n3. Run flutter pub get to install dependencies\n4. Set up project structure with appropriate folders for models, services, screens\n5. Configure minimum SDK versions in android/app/build.gradle for Firebase compatibility",
            "status": "completed",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Set Up Firebase Project and Platform Configuration",
            "description": "Create a Firebase project and configure platform-specific settings for iOS and Android.",
            "dependencies": [
              1
            ],
            "details": "1. Create a new Firebase project in the Firebase console\n2. Register Android app: add package name, download google-services.json, place in android/app/\n3. Register iOS app: add bundle ID, download GoogleService-Info.plist, place in iOS/Runner\n4. Update Android build files: modify android/build.gradle and android/app/build.gradle\n5. Update iOS build files: configure Podfile and Info.plist\n6. Enable required Firebase services (Authentication, Firestore, etc.) in Firebase console",
            "status": "completed",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Initialize Firebase and Set Up Core Services",
            "description": "Implement Firebase initialization in the Flutter app and configure core Firebase services.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Create a firebase_options.dart file using flutterfire CLI\n2. Implement Firebase initialization in main.dart using Firebase.initializeApp()\n3. Create service classes for Firebase Authentication\n4. Create service classes for Firestore database operations\n5. Implement error handling for Firebase operations\n6. Set up Firebase Analytics for tracking app usage\n7. Test basic Firebase connectivity and operations",
            "status": "completed",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Configure Firebase Security Rules and Testing",
            "description": "Set up security rules for Firebase services and perform comprehensive testing.",
            "dependencies": [
              3
            ],
            "details": "1. Define Firestore security rules to protect data\n2. Configure Firebase Authentication security settings\n3. Set up Firebase Storage security rules if needed\n4. Create test cases for authentication flows\n5. Test database operations with security rules in place\n6. Verify cross-platform functionality on both iOS and Android\n7. Document the Firebase integration setup and security configuration\n8. Perform final integration testing of all Firebase services",
            "status": "completed",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Data Models and Repository Pattern",
        "description": "Create data models for Jobs, Users, and Locals collections as specified in the PRD, and implement the repository pattern for data access.",
        "details": "1. Create model classes for each collection:\n\n```dart\n// job_model.dart\nclass Job {\n  final int local;\n  final String classification;\n  final String company;\n  final String location;\n  final String hours;\n  final String wage;\n  final String typeOfWork;\n  final String qualifications;\n  final String perDiem;\n  final String startDate;\n  final String duration;\n  final String numberOfJobs;\n  final DateTime timestamp;\n  \n  // Constructor, fromJson, toJson methods\n}\n\n// user_model.dart\nclass User {\n  // Personal Information\n  final String email;\n  final String firstName;\n  final String lastName;\n  final String phoneNumber;\n  final String address;\n  final String city;\n  final String state;\n  final String zipcode;\n  final String photoUrl;\n  \n  // IBEW Information\n  final int homeLocal;\n  final int ticketNumber;\n  final String classification;\n  final bool isWorking;\n  \n  // Preferences\n  final List<String> constructionTypes;\n  final double minHourlyRate;\n  final double maxHourlyRate;\n  final int preferredLocal1;\n  final int preferredLocal2;\n  final int preferredLocal3;\n  final Map<String, bool> careerGoals;\n  \n  // System\n  final String uid;\n  final DateTime createdTime;\n  final String onboardingStatus;\n  \n  // Constructor, fromJson, toJson methods\n}\n\n// local_model.dart\nclass Local {\n  final String localUnion;\n  final String city;\n  final String state;\n  final String address;\n  final String phone;\n  final String fax;\n  final String email;\n  final String website;\n  \n  // Leadership\n  final String businessManager;\n  final String president;\n  final String financialSecretary;\n  final String recordingSecretary;\n  \n  final String meetingSchedule;\n  \n  // Procedures\n  final String initialSign;\n  final String reSign;\n  final String reSignProcedure;\n  \n  // Constructor, fromJson, toJson methods\n}\n```\n\n2. Implement repository interfaces and implementations:\n\n```dart\n// job_repository.dart\nabstract class JobRepository {\n  Stream<List<Job>> getJobs();\n  Stream<List<Job>> getFilteredJobs(Map<String, dynamic> filters);\n  Future<Job> getJobById(String jobId);\n}\n\nclass FirebaseJobRepository implements JobRepository {\n  final FirebaseFirestore _firestore = FirebaseFirestore.instance;\n  \n  @override\n  Stream<List<Job>> getJobs() {\n    return _firestore.collection('jobs')\n        .orderBy('timestamp', descending: true)\n        .snapshots()\n        .map((snapshot) => snapshot.docs\n            .map((doc) => Job.fromJson(doc.data()))\n            .toList());\n  }\n  \n  // Implement other methods\n}\n\n// Similar implementations for UserRepository and LocalRepository\n```\n\n3. Create a repository provider for dependency injection:\n\n```dart\n// repository_provider.dart\nclass RepositoryProvider extends InheritedWidget {\n  final JobRepository jobRepository;\n  final UserRepository userRepository;\n  final LocalRepository localRepository;\n  \n  // Constructor and of method implementation\n}\n```",
        "testStrategy": "1. Write unit tests for model serialization/deserialization\n2. Create mock repositories for testing\n3. Test repository methods with Firebase Emulator Suite\n4. Verify data integrity with sample data\n5. Test filtering and query functionality\n6. Validate error handling for repository operations",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "completed",
        "subtasks": [
          {
            "id": 1,
            "title": "Define core data model classes with serialization",
            "description": "Create the fundamental data model classes that represent the application's domain objects with proper serialization/deserialization support.",
            "dependencies": [],
            "details": "1. Create model classes for User, Task, Project, and any other core entities\n2. Implement toJson() and fromJson() methods for each model\n3. Add proper validation logic within constructors\n4. Implement equality and hashCode methods\n5. Add documentation for each model class and its properties\n6. Ensure models support null safety",
            "status": "completed",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Design repository interfaces",
            "description": "Define the abstract repository interfaces that will provide the contract for data operations.",
            "dependencies": [
              1
            ],
            "details": "1. Create BaseRepository interface with common CRUD operations\n2. Define specific repository interfaces (UserRepository, TaskRepository, etc.)\n3. Document method signatures with clear parameter and return type expectations\n4. Define error handling approach (exceptions vs. Result objects)\n5. Consider pagination and filtering requirements in interface design",
            "status": "completed",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Firebase repository classes",
            "description": "Create concrete implementations of the repository interfaces using Firebase as the data source.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Implement FirebaseUserRepository, FirebaseTaskRepository, etc.\n2. Set up Firestore collections and document references\n3. Implement CRUD operations using Firebase SDK\n4. Add error handling and data validation\n5. Implement efficient querying and filtering\n6. Handle offline capabilities and synchronization",
            "status": "completed",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create repository provider for dependency injection",
            "description": "Implement a provider system to inject repository implementations throughout the application.",
            "dependencies": [
              2,
              3
            ],
            "details": "1. Create a RepositoryProvider class to manage repository instances\n2. Implement factory methods for each repository type\n3. Set up dependency injection using Provider or GetIt\n4. Configure repository initialization in the app startup\n5. Add support for switching repository implementations (e.g., for testing)",
            "status": "completed",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Write unit tests for models and repositories",
            "description": "Create comprehensive unit tests for data models and repository implementations.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "1. Write tests for model serialization/deserialization\n2. Create mock implementations of repositories for testing\n3. Test CRUD operations in repository implementations\n4. Test error handling and edge cases\n5. Set up test fixtures and helper methods\n6. Ensure high test coverage for critical components",
            "status": "completed",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement Authentication System",
        "description": "Develop the authentication system with multiple sign-in methods (Email/Password, Google Sign-In, Apple Sign-In) as specified in the PRD.",
        "details": "1. Create an AuthService class to handle authentication:\n\n```dart\nclass AuthService {\n  final FirebaseAuth _auth = FirebaseAuth.instance;\n  final GoogleSignIn _googleSignIn = GoogleSignIn();\n  \n  // Get current user\n  User? get currentUser => _auth.currentUser;\n  \n  // Auth state changes stream\n  Stream<User?> get authStateChanges => _auth.authStateChanges();\n  \n  // Email & Password Sign Up\n  Future<UserCredential> signUpWithEmailAndPassword(String email, String password) async {\n    return await _auth.createUserWithEmailAndPassword(\n      email: email,\n      password: password,\n    );\n  }\n  \n  // Email & Password Sign In\n  Future<UserCredential> signInWithEmailAndPassword(String email, String password) async {\n    return await _auth.signInWithEmailAndPassword(\n      email: email,\n      password: password,\n    );\n  }\n  \n  // Google Sign In\n  Future<UserCredential> signInWithGoogle() async {\n    final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();\n    final GoogleSignInAuthentication googleAuth = await googleUser!.authentication;\n    final credential = GoogleAuthProvider.credential(\n      accessToken: googleAuth.accessToken,\n      idToken: googleAuth.idToken,\n    );\n    return await _auth.signInWithCredential(credential);\n  }\n  \n  // Apple Sign In\n  Future<UserCredential> signInWithApple() async {\n    final appleProvider = AppleAuthProvider();\n    if (Platform.isIOS) {\n      return await _auth.signInWithProvider(appleProvider);\n    } else {\n      // Handle Android Apple Sign In with Firebase Custom Token\n      // Implementation details here\n    }\n  }\n  \n  // Sign Out\n  Future<void> signOut() async {\n    await _googleSignIn.signOut();\n    await _auth.signOut();\n  }\n}\n```\n\n2. Create an AuthProvider using Provider package:\n\n```dart\nclass AuthProvider extends ChangeNotifier {\n  final AuthService _authService = AuthService();\n  User? _user;\n  bool _isLoading = false;\n  String? _error;\n  \n  User? get user => _user;\n  bool get isLoading => _isLoading;\n  String? get error => _error;\n  bool get isAuthenticated => _user != null;\n  \n  AuthProvider() {\n    _authService.authStateChanges.listen((User? user) {\n      _user = user;\n      notifyListeners();\n    });\n  }\n  \n  // Implement sign in, sign up, and sign out methods that call AuthService\n}\n```\n\n3. Configure GoRouter with authentication guards:\n\n```dart\nfinal router = GoRouter(\n  routes: [\n    GoRoute(\n      path: '/',\n      redirect: (context, state) {\n        final authProvider = Provider.of<AuthProvider>(context, listen: false);\n        return authProvider.isAuthenticated ? null : '/login';\n      },\n      builder: (context, state) => const HomeScreen(),\n    ),\n    GoRoute(\n      path: '/login',\n      builder: (context, state) => const LoginScreen(),\n    ),\n    // Other routes\n  ],\n);\n```\n\n4. Create login, signup, and profile screens with appropriate UI elements",
        "testStrategy": "1. Test each authentication method separately\n2. Verify error handling for invalid credentials\n3. Test authentication state persistence\n4. Validate route protection and redirects\n5. Test sign-out functionality\n6. Verify user profile creation after authentication\n7. Test authentication with Firebase Authentication Emulator",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Email/Password Authentication",
            "description": "Create the email and password authentication functionality including registration, login, password reset, and email verification.",
            "dependencies": [],
            "details": "Implement Firebase Authentication for email/password sign-in. Create functions for user registration, login, logout, password reset, and email verification. Add validation for email format and password strength. Implement error handling for authentication failures.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Integrate Google Sign-In",
            "description": "Implement Google Sign-In authentication across all supported platforms.",
            "dependencies": [
              1
            ],
            "details": "Configure Firebase project for Google authentication. Set up Google Cloud project and obtain necessary API keys. Implement platform-specific Google Sign-In for iOS and Android. Handle user account linking if the email already exists. Test sign-in flow on all supported platforms.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Integrate Apple Sign-In",
            "description": "Implement Apple Sign-In authentication for iOS devices and web platforms.",
            "dependencies": [
              1
            ],
            "details": "Register app with Apple Developer account. Configure Firebase for Apple authentication. Implement Apple Sign-In SDK integration. Handle user account linking if the email already exists. Ensure compliance with Apple's authentication requirements. Test on iOS devices and web platforms.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create AuthService and AuthProvider",
            "description": "Develop a service layer and provider for authentication operations and state management.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create an AuthService class to abstract authentication methods. Implement AuthProvider using React Context API. Add methods for all authentication operations. Implement token refresh and session persistence. Create hooks for accessing authentication context throughout the app.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Authentication State Management and Routing",
            "description": "Set up state management for authentication and implement protected routes based on auth state.",
            "dependencies": [
              4
            ],
            "details": "Create authentication state listeners. Implement loading states during authentication operations. Set up protected routes that redirect unauthenticated users. Handle deep linking and route redirection after authentication. Implement session timeout and automatic logout functionality.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Develop Authentication UI Screens",
            "description": "Design and implement all UI screens related to authentication.",
            "dependencies": [
              4,
              5
            ],
            "details": "Create login, registration, password reset, and verification screens. Implement social login buttons with appropriate branding. Design error messages and validation feedback. Ensure accessibility compliance. Add loading indicators for authentication operations. Test UI across different device sizes.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement Core Navigation and UI Structure",
        "description": "Develop the main navigation structure with bottom navigation bar and implement the app's UI theme according to the design system specified in the PRD.",
        "details": "1. Create a theme configuration in a separate file:\n\n```dart\n// app_theme.dart\nclass AppTheme {\n  static ThemeData get lightTheme {\n    return ThemeData(\n      primaryColor: const Color(0xFF1a202c), // Deep Navy\n      colorScheme: ColorScheme.light(\n        primary: const Color(0xFF1a202c),\n        secondary: const Color(0xFFb45309), // Copper\n      ),\n      fontFamily: 'Roboto',\n      // Other theme configurations\n    );\n  }\n}\n```\n\n2. Implement the main app structure with bottom navigation:\n\n```dart\nclass MainApp extends StatefulWidget {\n  @override\n  _MainAppState createState() => _MainAppState();\n}\n\nclass _MainAppState extends State<MainApp> {\n  int _currentIndex = 0;\n  \n  final List<Widget> _screens = [\n    JobsScreen(),\n    LocalsScreen(),\n    ProfileScreen(),\n    MoreScreen(),\n  ];\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: _screens[_currentIndex],\n      bottomNavigationBar: BottomNavigationBar(\n        currentIndex: _currentIndex,\n        onTap: (index) {\n          setState(() {\n            _currentIndex = index;\n          });\n        },\n        type: BottomNavigationBarType.fixed,\n        items: const [\n          BottomNavigationBarItem(\n            icon: Icon(Icons.work),\n            label: 'Jobs',\n          ),\n          BottomNavigationBarItem(\n            icon: Icon(Icons.location_city),\n            label: 'Locals',\n          ),\n          BottomNavigationBarItem(\n            icon: Icon(Icons.person),\n            label: 'Profile',\n          ),\n          BottomNavigationBarItem(\n            icon: Icon(Icons.more_horiz),\n            label: 'More',\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n3. Create placeholder screens for each main section:\n   - JobsScreen\n   - LocalsScreen\n   - ProfileScreen\n   - MoreScreen\n\n4. Implement the splash screen and onboarding flow:\n\n```dart\nclass SplashScreen extends StatefulWidget {\n  @override\n  _SplashScreenState createState() => _SplashScreenState();\n}\n\nclass _SplashScreenState extends State<SplashScreen> {\n  @override\n  void initState() {\n    super.initState();\n    _navigateToNextScreen();\n  }\n  \n  Future<void> _navigateToNextScreen() async {\n    await Future.delayed(const Duration(seconds: 2));\n    final authProvider = Provider.of<AuthProvider>(context, listen: false);\n    if (authProvider.isAuthenticated) {\n      // Check if onboarding is completed\n      final prefs = await SharedPreferences.getInstance();\n      final onboardingCompleted = prefs.getBool('onboarding_completed') ?? false;\n      if (onboardingCompleted) {\n        context.go('/');\n      } else {\n        context.go('/onboarding');\n      }\n    } else {\n      context.go('/login');\n    }\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      backgroundColor: Theme.of(context).primaryColor,\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Image.asset('assets/logo.png', width: 200),\n            const SizedBox(height: 24),\n            const CircularProgressIndicator(color: Color(0xFFb45309)),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n5. Create reusable UI components for consistent design:\n   - Custom buttons\n   - Card designs\n   - Input fields\n   - Loading indicators",
        "testStrategy": "1. Test navigation flow between main screens\n2. Verify theme consistency across the app\n3. Test responsive layout on different screen sizes\n4. Validate splash screen and onboarding flow\n5. Test navigation guards based on authentication state\n6. Verify UI components render correctly\n7. Test accessibility features (contrast, tap targets, etc.)",
        "priority": "high",
        "dependencies": [
          1,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Theme Configuration and Styling System",
            "description": "Set up the app's theme configuration and styling system to ensure consistent visual appearance across all screens.",
            "dependencies": [],
            "details": "Create a comprehensive theming system including: color palette definition (primary, secondary, accent colors), typography styles (font families, sizes, weights), spacing and layout constants, dark/light mode support, and theme provider implementation. Ensure the theme can be easily applied throughout the app and modified centrally.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Bottom Navigation Bar and Main Screen Structure",
            "description": "Implement the bottom navigation bar and define the main screen structure for the application.",
            "dependencies": [
              1
            ],
            "details": "Create a bottom navigation component with icons and labels for main app sections (Home, Search, Library, Profile). Implement navigation state management and screen transitions. Set up the container structure for main screens that will host content. Ensure proper handling of navigation history and back button behavior.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Splash Screen and Initial Routing Logic",
            "description": "Develop the splash screen and implement the initial routing logic to direct users to the appropriate screens.",
            "dependencies": [
              1
            ],
            "details": "Design and implement an animated splash screen with the app logo. Create routing logic to determine initial destination based on user state (new user, returning user, logged in/out). Implement necessary authentication state checks and session validation. Ensure smooth transitions from splash to subsequent screens.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Onboarding Flow Implementation",
            "description": "Create the onboarding flow for new users with multiple screens explaining app features and benefits.",
            "dependencies": [
              1,
              3
            ],
            "details": "Design and implement a multi-step onboarding flow with: welcome screen, feature highlight pages, permission request screens (if needed), and account creation/login options. Add pagination indicators, navigation buttons (skip, next, back), and animations for transitions between steps. Implement logic to show onboarding only to new users.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Reusable UI Components Library",
            "description": "Develop a library of reusable UI components to maintain consistency across the application.",
            "dependencies": [
              1
            ],
            "details": "Create a comprehensive set of reusable components including: buttons (primary, secondary, text, icon), input fields and forms, cards and list items, loading indicators and skeletons, error and empty states, modals and dialogs, and typography components. Document usage patterns and provide examples for each component.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Job Listings and Filtering",
        "description": "Develop the job listings screen with real-time data from Firestore and implement advanced filtering functionality as specified in the PRD.",
        "details": "1. Create the JobsScreen with a ListView.builder for efficient rendering:\n\n```dart\nclass JobsScreen extends StatefulWidget {\n  @override\n  _JobsScreenState createState() => _JobsScreenState();\n}\n\nclass _JobsScreenState extends State<JobsScreen> {\n  final JobRepository _jobRepository = FirebaseJobRepository();\n  Map<String, dynamic> _activeFilters = {};\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Jobs'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.filter_list),\n            onPressed: () => _showFilterDialog(),\n          ),\n          IconButton(\n            icon: const Icon(Icons.search),\n            onPressed: () => _showSearchDialog(),\n          ),\n        ],\n      ),\n      body: Column(\n        children: [\n          // Filter chips\n          if (_activeFilters.isNotEmpty)\n            SingleChildScrollView(\n              scrollDirection: Axis.horizontal,\n              child: Row(\n                children: _activeFilters.entries.map((entry) {\n                  return Padding(\n                    padding: const EdgeInsets.symmetric(horizontal: 4.0),\n                    child: Chip(\n                      label: Text('${entry.key}: ${entry.value}'),\n                      onDeleted: () {\n                        setState(() {\n                          _activeFilters.remove(entry.key);\n                        });\n                      },\n                    ),\n                  );\n                }).toList(),\n              ),\n            ),\n          // Job listings\n          Expanded(\n            child: StreamBuilder<List<Job>>(\n              stream: _activeFilters.isEmpty\n                  ? _jobRepository.getJobs()\n                  : _jobRepository.getFilteredJobs(_activeFilters),\n              builder: (context, snapshot) {\n                if (snapshot.connectionState == ConnectionState.waiting) {\n                  return const Center(child: CircularProgressIndicator());\n                }\n                \n                if (snapshot.hasError) {\n                  return Center(child: Text('Error: ${snapshot.error}'));\n                }\n                \n                final jobs = snapshot.data ?? [];\n                \n                if (jobs.isEmpty) {\n                  return const Center(child: Text('No jobs found'));\n                }\n                \n                return ListView.builder(\n                  itemCount: jobs.length,\n                  itemBuilder: (context, index) {\n                    final job = jobs[index];\n                    return JobCard(\n                      job: job,\n                      onTap: () => _navigateToJobDetails(job),\n                    );\n                  },\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n  \n  void _showFilterDialog() {\n    // Implement filter dialog with options for:\n    // - Local union number\n    // - Classification\n    // - Location/geographic area\n    // - Wage range\n    // - Type of work\n    // - Duration and start date\n  }\n  \n  void _showSearchDialog() {\n    // Implement search functionality\n  }\n  \n  void _navigateToJobDetails(Job job) {\n    // Navigate to job details screen\n  }\n}\n```\n\n2. Create a JobCard widget for displaying job listings:\n\n```dart\nclass JobCard extends StatelessWidget {\n  final Job job;\n  final VoidCallback onTap;\n  \n  const JobCard({required this.job, required this.onTap});\n  \n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\n      child: InkWell(\n        onTap: onTap,\n        child: Padding(\n          padding: const EdgeInsets.all(16),\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n              Row(\n                mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                children: [\n                  Text(\n                    'Local ${job.local}',\n                    style: const TextStyle(fontWeight: FontWeight.bold),\n                  ),\n                  Text(\n                    job.wage,\n                    style: const TextStyle(fontWeight: FontWeight.bold),\n                  ),\n                ],\n              ),\n              const SizedBox(height: 8),\n              Text(job.company),\n              Text(job.location),\n              const SizedBox(height: 8),\n              Text('Type: ${job.typeOfWork}'),\n              Text('Start: ${job.startDate}'),\n              Text('Duration: ${job.duration}'),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n3. Implement the JobDetailsScreen:\n\n```dart\nclass JobDetailsScreen extends StatelessWidget {\n  final Job job;\n  \n  const JobDetailsScreen({required this.job});\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Local ${job.local} Job'),\n      ),\n      body: SingleChildScrollView(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            // Company section\n            Text(\n              job.company,\n              style: Theme.of(context).textTheme.headline5,\n            ),\n            Text(job.location),\n            const Divider(),\n            \n            // Wage section\n            ListTile(\n              leading: const Icon(Icons.attach_money),\n              title: const Text('Hourly Rate'),\n              subtitle: Text(job.wage),\n            ),\n            if (job.perDiem.isNotEmpty)\n              ListTile(\n                leading: const Icon(Icons.card_travel),\n                title: const Text('Per Diem'),\n                subtitle: Text(job.perDiem),\n              ),\n            \n            // Job details section\n            const SizedBox(height: 16),\n            Text(\n              'Job Details',\n              style: Theme.of(context).textTheme.headline6,\n            ),\n            const SizedBox(height: 8),\n            DetailItem(label: 'Classification', value: job.classification),\n            DetailItem(label: 'Type of Work', value: job.typeOfWork),\n            DetailItem(label: 'Work Schedule', value: job.hours),\n            DetailItem(label: 'Start Date', value: job.startDate),\n            DetailItem(label: 'Duration', value: job.duration),\n            DetailItem(label: 'Positions Available', value: job.numberOfJobs),\n            \n            // Qualifications section\n            const SizedBox(height: 16),\n            Text(\n              'Qualifications',\n              style: Theme.of(context).textTheme.headline6,\n            ),\n            const SizedBox(height: 8),\n            Text(job.qualifications),\n            \n            const SizedBox(height: 24),\n            ElevatedButton(\n              onPressed: () {\n                // Implement job application logic\n              },\n              child: const Text('Apply for This Job'),\n              style: ElevatedButton.styleFrom(\n                minimumSize: const Size(double.infinity, 50),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass DetailItem extends StatelessWidget {\n  final String label;\n  final String value;\n  \n  const DetailItem({required this.label, required this.value});\n  \n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 4),\n      child: Row(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          SizedBox(\n            width: 120,\n            child: Text(\n              '$label:',\n              style: const TextStyle(fontWeight: FontWeight.bold),\n            ),\n          ),\n          Expanded(child: Text(value)),\n        ],\n      ),\n    );\n  }\n}\n```\n\n4. Implement the filter dialog with all filtering options specified in the PRD",
        "testStrategy": "1. Test real-time data loading from Firestore\n2. Verify filter functionality for each filter type\n3. Test job card rendering with different data\n4. Validate job details screen displays all information correctly\n5. Test empty state and error handling\n6. Verify performance with large datasets\n7. Test search functionality\n8. Validate UI responsiveness on different screen sizes",
        "priority": "high",
        "dependencies": [
          2,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement basic job listing screen with Firestore integration",
            "description": "Create the main job listing screen that fetches and displays job data from Firestore",
            "dependencies": [],
            "details": "Create a JobListingScreen widget that connects to Firestore and retrieves job listings. Implement a StreamBuilder to handle real-time data. Set up the basic layout with a ListView or GridView to display job cards. Include loading states and error handling for Firestore connection issues.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Develop reusable job card UI component",
            "description": "Create a visually appealing and informative job card component to display in the listing",
            "dependencies": [
              1
            ],
            "details": "Design and implement a JobCard widget that displays key job information (title, company, location, salary range, etc.). Add appropriate styling, animations, and touch feedback. Ensure the card is responsive and works well in different screen sizes. Include placeholder handling for missing data.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build job details screen",
            "description": "Create a detailed view screen that shows complete information about a selected job",
            "dependencies": [
              2
            ],
            "details": "Implement JobDetailsScreen that receives a job ID or object and displays comprehensive information. Include sections for job description, requirements, benefits, application process, etc. Add navigation from job cards to this screen. Implement UI elements like expandable sections, apply button, and share functionality.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create filter dialog with multiple filter options",
            "description": "Implement a comprehensive filter dialog allowing users to filter jobs by various criteria",
            "dependencies": [
              1
            ],
            "details": "Design and build a FilterDialog widget with options for filtering by job type, location, salary range, experience level, etc. Implement form controls (checkboxes, sliders, dropdowns) for each filter type. Add reset and apply buttons. Ensure filter state persistence between app sessions.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement search functionality",
            "description": "Add search capability to find jobs by keywords in titles, descriptions, or other fields",
            "dependencies": [
              1,
              4
            ],
            "details": "Add a search bar to the job listing screen. Implement text-based search logic that works with Firestore queries. Support searching across multiple fields (title, company, skills, etc.). Add debouncing to prevent excessive queries during typing. Show appropriate UI for search results and no matches found.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Handle real-time data updates",
            "description": "Ensure the app properly handles real-time updates from Firestore",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Optimize StreamBuilder usage to efficiently handle Firestore updates. Implement proper state management to reflect changes in the UI immediately. Add visual indicators for new or updated job listings. Handle edge cases like updates during filtering or searching. Implement graceful error handling for stream interruptions.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Optimize performance for large datasets",
            "description": "Implement techniques to ensure smooth performance with large job listing datasets",
            "dependencies": [
              1,
              2,
              6
            ],
            "details": "Implement pagination or infinite scrolling to load jobs in batches. Add caching mechanisms to reduce Firestore reads. Optimize list rendering with ListView.builder or similar. Implement efficient filtering that minimizes query load on Firestore. Add performance monitoring and logging to identify bottlenecks. Consider implementing indexed search for better performance.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement User Profile and Preferences",
        "description": "Develop the user profile screen with IBEW member information and career preferences as specified in the PRD.",
        "details": "1. Create the ProfileScreen:\n\n```dart\nclass ProfileScreen extends StatefulWidget {\n  @override\n  _ProfileScreenState createState() => _ProfileScreenState();\n}\n\nclass _ProfileScreenState extends State<ProfileScreen> {\n  final UserRepository _userRepository = FirebaseUserRepository();\n  \n  @override\n  Widget build(BuildContext context) {\n    final authProvider = Provider.of<AuthProvider>(context);\n    final userId = authProvider.user?.uid;\n    \n    if (userId == null) {\n      return const Center(child: Text('Please sign in'));\n    }\n    \n    return StreamBuilder<User>(\n      stream: _userRepository.getUserById(userId),\n      builder: (context, snapshot) {\n        if (snapshot.connectionState == ConnectionState.waiting) {\n          return const Center(child: CircularProgressIndicator());\n        }\n        \n        if (snapshot.hasError) {\n          return Center(child: Text('Error: ${snapshot.error}'));\n        }\n        \n        final user = snapshot.data;\n        \n        if (user == null) {\n          return Center(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                const Text('Profile not set up yet'),\n                ElevatedButton(\n                  onPressed: () => _navigateToProfileSetup(),\n                  child: const Text('Set Up Profile'),\n                ),\n              ],\n            ),\n          );\n        }\n        \n        return DefaultTabController(\n          length: 3,\n          child: Scaffold(\n            appBar: AppBar(\n              title: const Text('My Profile'),\n              actions: [\n                IconButton(\n                  icon: const Icon(Icons.edit),\n                  onPressed: () => _navigateToEditProfile(user),\n                ),\n                IconButton(\n                  icon: const Icon(Icons.logout),\n                  onPressed: () => _confirmSignOut(),\n                ),\n              ],\n              bottom: const TabBar(\n                tabs: [\n                  Tab(text: 'Personal'),\n                  Tab(text: 'IBEW Info'),\n                  Tab(text: 'Preferences'),\n                ],\n              ),\n            ),\n            body: TabBarView(\n              children: [\n                _buildPersonalInfoTab(user),\n                _buildIBEWInfoTab(user),\n                _buildPreferencesTab(user),\n              ],\n            ),\n          ),\n        );\n      },\n    );\n  }\n  \n  Widget _buildPersonalInfoTab(User user) {\n    return SingleChildScrollView(\n      padding: const EdgeInsets.all(16),\n      child: Column(\n        children: [\n          Center(\n            child: CircleAvatar(\n              radius: 50,\n              backgroundImage: user.photoUrl.isNotEmpty\n                  ? CachedNetworkImageProvider(user.photoUrl)\n                  : null,\n              child: user.photoUrl.isEmpty\n                  ? Text(\n                      user.firstName.isNotEmpty && user.lastName.isNotEmpty\n                          ? '${user.firstName[0]}${user.lastName[0]}'\n                          : '',\n                      style: const TextStyle(fontSize: 30),\n                    )\n                  : null,\n            ),\n          ),\n          const SizedBox(height: 16),\n          Text(\n            '${user.firstName} ${user.lastName}',\n            style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n          ),\n          const SizedBox(height: 24),\n          InfoItem(label: 'Email', value: user.email),\n          InfoItem(label: 'Phone', value: user.phoneNumber),\n          InfoItem(label: 'Address', value: '${user.address}, ${user.city}, ${user.state} ${user.zipcode}'),\n        ],\n      ),\n    );\n  }\n  \n  Widget _buildIBEWInfoTab(User user) {\n    return SingleChildScrollView(\n      padding: const EdgeInsets.all(16),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          const Text(\n            'IBEW Information',\n            style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n          ),\n          const SizedBox(height: 16),\n          InfoItem(label: 'Home Local', value: user.homeLocal.toString()),\n          InfoItem(label: 'Ticket Number', value: user.ticketNumber.toString()),\n          InfoItem(label: 'Classification', value: user.classification),\n          InfoItem(label: 'Current Status', value: user.isWorking ? 'Working' : 'Not Working'),\n        ],\n      ),\n    );\n  }\n  \n  Widget _buildPreferencesTab(User user) {\n    return SingleChildScrollView(\n      padding: const EdgeInsets.all(16),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          const Text(\n            'Work Preferences',\n            style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n          ),\n          const SizedBox(height: 16),\n          InfoItem(\n            label: 'Hourly Rate Range',\n            value: '\\$${user.minHourlyRate.toStringAsFixed(2)} - \\$${user.maxHourlyRate.toStringAsFixed(2)}',\n          ),\n          InfoItem(\n            label: 'Construction Types',\n            value: user.constructionTypes.join(', '),\n          ),\n          InfoItem(\n            label: 'Preferred Locals',\n            value: [\n              if (user.preferredLocal1 > 0) user.preferredLocal1.toString(),\n              if (user.preferredLocal2 > 0) user.preferredLocal2.toString(),\n              if (user.preferredLocal3 > 0) user.preferredLocal3.toString(),\n            ].join(', '),\n          ),\n          const SizedBox(height: 16),\n          const Text(\n            'Career Goals',\n            style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n          ),\n          const SizedBox(height: 8),\n          ...user.careerGoals.entries.map((entry) {\n            if (entry.value) {\n              return Padding(\n                padding: const EdgeInsets.symmetric(vertical: 4),\n                child: Row(\n                  children: [\n                    const Icon(Icons.check_circle, color: Colors.green),\n                    const SizedBox(width: 8),\n                    Text(entry.key),\n                  ],\n                ),\n              );\n            } else {\n              return const SizedBox.shrink();\n            }\n          }).toList(),\n        ],\n      ),\n    );\n  }\n  \n  void _navigateToProfileSetup() {\n    // Navigate to profile setup screen\n  }\n  \n  void _navigateToEditProfile(User user) {\n    // Navigate to edit profile screen\n  }\n  \n  void _confirmSignOut() {\n    showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: const Text('Sign Out'),\n        content: const Text('Are you sure you want to sign out?'),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.pop(context),\n            child: const Text('Cancel'),\n          ),\n          TextButton(\n            onPressed: () {\n              Navigator.pop(context);\n              Provider.of<AuthProvider>(context, listen: false).signOut();\n            },\n            child: const Text('Sign Out'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass InfoItem extends StatelessWidget {\n  final String label;\n  final String value;\n  \n  const InfoItem({required this.label, required this.value});\n  \n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 8),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          Text(\n            label,\n            style: const TextStyle(fontSize: 14, color: Colors.grey),\n          ),\n          const SizedBox(height: 4),\n          Text(\n            value,\n            style: const TextStyle(fontSize: 16),\n          ),\n          const Divider(),\n        ],\n      ),\n    );\n  }\n}\n```\n\n2. Create the ProfileSetupScreen for new users:\n\n```dart\nclass ProfileSetupScreen extends StatefulWidget {\n  @override\n  _ProfileSetupScreenState createState() => _ProfileSetupScreenState();\n}\n\nclass _ProfileSetupScreenState extends State<ProfileSetupScreen> {\n  final _formKey = GlobalKey<FormState>();\n  final UserRepository _userRepository = FirebaseUserRepository();\n  \n  // Form controllers for all user fields\n  final _firstNameController = TextEditingController();\n  final _lastNameController = TextEditingController();\n  // Add controllers for all other fields\n  \n  int _currentStep = 0;\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Set Up Your Profile'),\n      ),\n      body: Form(\n        key: _formKey,\n        child: Stepper(\n          currentStep: _currentStep,\n          onStepContinue: () {\n            if (_currentStep < 2) {\n              setState(() {\n                _currentStep += 1;\n              });\n            } else {\n              _submitForm();\n            }\n          },\n          onStepCancel: () {\n            if (_currentStep > 0) {\n              setState(() {\n                _currentStep -= 1;\n              });\n            }\n          },\n          steps: [\n            Step(\n              title: const Text('Personal Information'),\n              content: _buildPersonalInfoStep(),\n              isActive: _currentStep >= 0,\n            ),\n            Step(\n              title: const Text('IBEW Information'),\n              content: _buildIBEWInfoStep(),\n              isActive: _currentStep >= 1,\n            ),\n            Step(\n              title: const Text('Work Preferences'),\n              content: _buildPreferencesStep(),\n              isActive: _currentStep >= 2,\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n  \n  Widget _buildPersonalInfoStep() {\n    // Build form fields for personal information\n  }\n  \n  Widget _buildIBEWInfoStep() {\n    // Build form fields for IBEW information\n  }\n  \n  Widget _buildPreferencesStep() {\n    // Build form fields for work preferences and career goals\n  }\n  \n  void _submitForm() async {\n    if (_formKey.currentState!.validate()) {\n      // Show loading indicator\n      // Create user object from form data\n      // Save to Firestore\n      // Navigate to home screen\n    }\n  }\n}\n```\n\n3. Create the EditProfileScreen for updating user information",
        "testStrategy": "1. Test profile data loading from Firestore\n2. Verify form validation for all input fields\n3. Test profile creation for new users\n4. Validate profile updates\n5. Test tab navigation and UI rendering\n6. Verify image upload functionality\n7. Test error handling for form submission\n8. Validate user preferences are correctly saved and displayed",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Profile Data Model and Repository",
            "description": "Design and implement the user profile data model and repository methods for CRUD operations",
            "dependencies": [],
            "details": "Create a UserProfile model with fields for personal info, preferences, and profile image references. Implement repository methods for fetching, creating, updating profiles. Include validation logic for required fields and data types. Set up database schema and migrations if needed.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Profile Viewing UI with Tabbed Interface",
            "description": "Design and build the profile viewing interface with tabs for different sections of user information",
            "dependencies": [
              1
            ],
            "details": "Create a responsive profile page with tabs for Personal Info, Preferences, Activity History, etc. Implement tab navigation and content switching. Design layout for displaying profile data in an organized manner. Include placeholder for profile image. Ensure accessibility compliance.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Develop Profile Setup Wizard for New Users",
            "description": "Create a multi-step wizard to guide new users through setting up their profile",
            "dependencies": [
              1
            ],
            "details": "Design a step-by-step wizard with progress indicator. Implement form validation for each step. Create a smooth navigation between steps with back/next buttons. Store partial progress to prevent data loss. Include final review step before submission. Redirect to completed profile after setup.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Build Profile Editing Functionality",
            "description": "Implement the ability for users to edit their existing profile information",
            "dependencies": [
              1,
              2
            ],
            "details": "Create edit forms for each profile section. Implement form validation and error handling. Add save/cancel buttons with appropriate confirmation dialogs. Ensure real-time feedback on successful updates. Include field-level editing capabilities where appropriate.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Preferences Management",
            "description": "Create functionality for users to set and update their application preferences",
            "dependencies": [
              1,
              4
            ],
            "details": "Design UI for managing user preferences (notifications, privacy settings, theme, etc.). Implement toggle switches, dropdowns, and other appropriate controls. Create backend methods to store and retrieve preference settings. Ensure changes take effect immediately where applicable. Add default preferences for new users.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Develop Profile Image Handling and Storage",
            "description": "Implement functionality for uploading, cropping, and storing user profile images",
            "dependencies": [
              1,
              2
            ],
            "details": "Create image upload component with drag-and-drop support. Implement image cropping/resizing functionality. Set up secure storage for images with appropriate access controls. Handle image format validation and size restrictions. Create fallback avatars for users without custom images. Implement caching strategy for efficient loading.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement Local Union Directory",
        "description": "Develop the local union directory with comprehensive information about IBEW locals as specified in the PRD.",
        "details": "1. Create the LocalsScreen with search and filtering:\n\n```dart\nclass LocalsScreen extends StatefulWidget {\n  @override\n  _LocalsScreenState createState() => _LocalsScreenState();\n}\n\nclass _LocalsScreenState extends State<LocalsScreen> {\n  final LocalRepository _localRepository = FirebaseLocalRepository();\n  String _searchQuery = '';\n  String _selectedState = '';\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('IBEW Locals'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.search),\n            onPressed: () => _showSearchDialog(),\n          ),\n        ],\n      ),\n      body: Column(\n        children: [\n          // State filter dropdown\n          Padding(\n            padding: const EdgeInsets.all(16),\n            child: DropdownButtonFormField<String>(\n              decoration: const InputDecoration(\n                labelText: 'Filter by State',\n                border: OutlineInputBorder(),\n              ),\n              value: _selectedState.isEmpty ? null : _selectedState,\n              items: [\n                const DropdownMenuItem(value: '', child: Text('All States')),\n                // Add all US states\n              ],\n              onChanged: (value) {\n                setState(() {\n                  _selectedState = value ?? '';\n                });\n              },\n            ),\n          ),\n          \n          // Locals list\n          Expanded(\n            child: StreamBuilder<List<Local>>(\n              stream: _localRepository.getLocals(\n                state: _selectedState.isEmpty ? null : _selectedState,\n                searchQuery: _searchQuery.isEmpty ? null : _searchQuery,\n              ),\n              builder: (context, snapshot) {\n                if (snapshot.connectionState == ConnectionState.waiting) {\n                  return const Center(child: CircularProgressIndicator());\n                }\n                \n                if (snapshot.hasError) {\n                  return Center(child: Text('Error: ${snapshot.error}'));\n                }\n                \n                final locals = snapshot.data ?? [];\n                \n                if (locals.isEmpty) {\n                  return const Center(child: Text('No locals found'));\n                }\n                \n                return ListView.builder(\n                  itemCount: locals.length,\n                  itemBuilder: (context, index) {\n                    final local = locals[index];\n                    return LocalCard(\n                      local: local,\n                      onTap: () => _navigateToLocalDetails(local),\n                    );\n                  },\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n  \n  void _showSearchDialog() {\n    showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: const Text('Search Locals'),\n        content: TextField(\n          autofocus: true,\n          decoration: const InputDecoration(\n            hintText: 'Enter local number or city',\n          ),\n          onChanged: (value) {\n            setState(() {\n              _searchQuery = value;\n            });\n          },\n        ),\n        actions: [\n          TextButton(\n            onPressed: () {\n              Navigator.pop(context);\n              setState(() {\n                _searchQuery = '';\n              });\n            },\n            child: const Text('Clear'),\n          ),\n          TextButton(\n            onPressed: () => Navigator.pop(context),\n            child: const Text('Search'),\n          ),\n        ],\n      ),\n    );\n  }\n  \n  void _navigateToLocalDetails(Local local) {\n    Navigator.push(\n      context,\n      MaterialPageRoute(\n        builder: (context) => LocalDetailsScreen(local: local),\n      ),\n    );\n  }\n}\n\nclass LocalCard extends StatelessWidget {\n  final Local local;\n  final VoidCallback onTap;\n  \n  const LocalCard({required this.local, required this.onTap});\n  \n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\n      child: InkWell(\n        onTap: onTap,\n        child: Padding(\n          padding: const EdgeInsets.all(16),\n          child: Row(\n            children: [\n              Container(\n                width: 60,\n                height: 60,\n                decoration: BoxDecoration(\n                  color: Theme.of(context).primaryColor,\n                  shape: BoxShape.circle,\n                ),\n                child: Center(\n                  child: Text(\n                    local.localUnion.replaceAll(RegExp(r'[^0-9]'), ''),\n                    style: const TextStyle(\n                      color: Colors.white,\n                      fontWeight: FontWeight.bold,\n                      fontSize: 18,\n                    ),\n                  ),\n                ),\n              ),\n              const SizedBox(width: 16),\n              Expanded(\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: [\n                    Text(\n                      'IBEW ${local.localUnion}',\n                      style: const TextStyle(\n                        fontWeight: FontWeight.bold,\n                        fontSize: 16,\n                      ),\n                    ),\n                    const SizedBox(height: 4),\n                    Text('${local.city}, ${local.state}'),\n                  ],\n                ),\n              ),\n              const Icon(Icons.chevron_right),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n2. Create the LocalDetailsScreen:\n\n```dart\nclass LocalDetailsScreen extends StatelessWidget {\n  final Local local;\n  \n  const LocalDetailsScreen({required this.local});\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('IBEW ${local.localUnion}'),\n      ),\n      body: SingleChildScrollView(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            // Header\n            Center(\n              child: Column(\n                children: [\n                  Container(\n                    width: 100,\n                    height: 100,\n                    decoration: BoxDecoration(\n                      color: Theme.of(context).primaryColor,\n                      shape: BoxShape.circle,\n                    ),\n                    child: Center(\n                      child: Text(\n                        local.localUnion.replaceAll(RegExp(r'[^0-9]'), ''),\n                        style: const TextStyle(\n                          color: Colors.white,\n                          fontWeight: FontWeight.bold,\n                          fontSize: 32,\n                        ),\n                      ),\n                    ),\n                  ),\n                  const SizedBox(height: 16),\n                  Text(\n                    'IBEW ${local.localUnion}',\n                    style: const TextStyle(\n                      fontSize: 24,\n                      fontWeight: FontWeight.bold,\n                    ),\n                  ),\n                  Text(\n                    '${local.city}, ${local.state}',\n                    style: const TextStyle(fontSize: 18),\n                  ),\n                ],\n              ),\n            ),\n            const Divider(height: 32),\n            \n            // Contact Information\n            const Text(\n              'Contact Information',\n              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 16),\n            ContactItem(\n              icon: Icons.location_on,\n              label: 'Address',\n              value: local.address,\n            ),\n            ContactItem(\n              icon: Icons.phone,\n              label: 'Phone',\n              value: local.phone,\n              onTap: () => _makePhoneCall(local.phone),\n            ),\n            if (local.fax.isNotEmpty)\n              ContactItem(\n                icon: Icons.print,\n                label: 'Fax',\n                value: local.fax,\n              ),\n            ContactItem(\n              icon: Icons.email,\n              label: 'Email',\n              value: local.email,\n              onTap: () => _sendEmail(local.email),\n            ),\n            ContactItem(\n              icon: Icons.language,\n              label: 'Website',\n              value: local.website,\n              onTap: () => _openWebsite(local.website),\n            ),\n            const Divider(height: 32),\n            \n            // Leadership\n            const Text(\n              'Leadership',\n              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 16),\n            LeadershipItem(title: 'Business Manager', name: local.businessManager),\n            LeadershipItem(title: 'President', name: local.president),\n            LeadershipItem(title: 'Financial Secretary', name: local.financialSecretary),\n            LeadershipItem(title: 'Recording Secretary', name: local.recordingSecretary),\n            const Divider(height: 32),\n            \n            // Meeting Schedule\n            const Text(\n              'Meeting Schedule',\n              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 16),\n            Text(local.meetingSchedule),\n            const Divider(height: 32),\n            \n            // Procedures\n            const Text(\n              'Sign-in Procedures',\n              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 16),\n            ProcedureItem(title: 'Initial Sign-in', procedure: local.initialSign),\n            ProcedureItem(title: 'Re-Sign', procedure: local.reSign),\n            ProcedureItem(title: 'Re-Sign Procedure', procedure: local.reSignProcedure),\n          ],\n        ),\n      ),\n    );\n  }\n  \n  void _makePhoneCall(String phoneNumber) async {\n    final url = 'tel:$phoneNumber';\n    if (await canLaunch(url)) {\n      await launch(url);\n    }\n  }\n  \n  void _sendEmail(String email) async {\n    final url = 'mailto:$email';\n    if (await canLaunch(url)) {\n      await launch(url);\n    }\n  }\n  \n  void _openWebsite(String website) async {\n    if (await canLaunch(website)) {\n      await launch(website);\n    }\n  }\n}\n\nclass ContactItem extends StatelessWidget {\n  final IconData icon;\n  final String label;\n  final String value;\n  final VoidCallback? onTap;\n  \n  const ContactItem({\n    required this.icon,\n    required this.label,\n    required this.value,\n    this.onTap,\n  });\n  \n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 8),\n      child: Row(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          Icon(icon, color: Theme.of(context).primaryColor),\n          const SizedBox(width: 16),\n          Expanded(\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                Text(\n                  label,\n                  style: const TextStyle(fontSize: 14, color: Colors.grey),\n                ),\n                const SizedBox(height: 4),\n                GestureDetector(\n                  onTap: onTap,\n                  child: Text(\n                    value,\n                    style: TextStyle(\n                      fontSize: 16,\n                      color: onTap != null ? Theme.of(context).colorScheme.secondary : null,\n                      decoration: onTap != null ? TextDecoration.underline : null,\n                    ),\n                  ),\n                ),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass LeadershipItem extends StatelessWidget {\n  final String title;\n  final String name;\n  \n  const LeadershipItem({required this.title, required this.name});\n  \n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 8),\n      child: Row(\n        children: [\n          SizedBox(\n            width: 150,\n            child: Text(\n              title,\n              style: const TextStyle(fontWeight: FontWeight.bold),\n            ),\n          ),\n          Expanded(child: Text(name)),\n        ],\n      ),\n    );\n  }\n}\n\nclass ProcedureItem extends StatelessWidget {\n  final String title;\n  final String procedure;\n  \n  const ProcedureItem({required this.title, required this.procedure});\n  \n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 8),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          Text(\n            title,\n            style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16),\n          ),\n          const SizedBox(height: 8),\n          Text(procedure),\n        ],\n      ),\n    );\n  }\n}\n```",
        "testStrategy": "1. Test local union data loading from Firestore\n2. Verify search functionality by local number and city\n3. Test state filtering\n4. Validate local details screen displays all information correctly\n5. Test contact action buttons (phone, email, website)\n6. Verify UI rendering on different screen sizes\n7. Test error handling for missing data\n8. Validate performance with large datasets",
        "priority": "medium",
        "dependencies": [
          2,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Locals Listing Screen",
            "description": "Create the main screen that displays all local unions with basic information in a scrollable list format",
            "dependencies": [],
            "details": "Develop the main screen layout with a header, search bar placeholder, and scrollable container for local union cards. Implement initial data fetching and display logic. Include loading states and error handling for data retrieval. Set up the basic navigation structure for the directory.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Develop Local Card UI Component",
            "description": "Create a reusable card component to display summary information for each local union",
            "dependencies": [
              1
            ],
            "details": "Design and implement a card component that displays the local union number, name, location, and a thumbnail or icon. Ensure the card is responsive and follows the app's design system. Add tap interaction to navigate to the details screen. Include visual indicators for different union types or statuses if applicable.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Local Details Screen",
            "description": "Implement a comprehensive details screen showing all information about a selected local union",
            "dependencies": [
              2
            ],
            "details": "Develop the details screen layout with sections for general information, leadership, jurisdiction, meeting information, and other relevant details. Implement data fetching for the specific local. Create a navigation header with back button. Design an appealing layout that organizes information logically and clearly.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Contact Actions",
            "description": "Add functionality to contact the local union via phone, email, and website",
            "dependencies": [
              3
            ],
            "details": "Create action buttons for phone calls, email composition, and website visits. Implement the integration with device capabilities to launch the appropriate apps (phone, email client, browser). Add visual feedback for button interactions. Include error handling for missing contact information.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Develop Search and Filtering Functionality",
            "description": "Implement search and state-based filtering for the locals listing",
            "dependencies": [
              1
            ],
            "details": "Create a search function that filters locals by name, number, or location. Implement state/region filtering with a dropdown or similar UI element. Add clear search and reset filters functionality. Ensure the filtering is performant even with a large number of locals. Update the UI to show active filters and search terms.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement AI-Powered Features",
        "description": "Develop the AI-powered features including intelligent job matching, career recommendations, and wage trend analysis using Google Generative AI, OpenAI, and Anthropic Claude APIs.",
        "details": "1. Create an AIService class to handle AI API interactions:\n\n```dart\nclass AIService {\n  final FirebaseFunctions _functions = FirebaseFunctions.instance;\n  final GenerativeModel _model = GenerativeModel(\n    model: 'gemini-pro',\n    apiKey: 'YOUR_GEMINI_API_KEY', // Store securely\n  );\n  \n  // Job matching using Google Generative AI\n  Future<List<String>> getJobRecommendations(User user) async {\n    try {\n      final content = [\n        Content.text(\n          \"Based on the following user profile, recommend job types and locations that would be a good match. \"  \n          \"User Profile: \"  \n          \"Classification: ${user.classification}, \"  \n          \"Preferred wage range: \\$${user.minHourlyRate} - \\$${user.maxHourlyRate}, \"  \n          \"Preferred construction types: ${user.constructionTypes.join(', ')}, \"  \n          \"Preferred locals: ${[user.preferredLocal1, user.preferredLocal2, user.preferredLocal3].where((local) => local > 0).join(', ')}, \"  \n          \"Career goals: ${user.careerGoals.entries.where((entry) => entry.value).map((entry) => entry.key).join(', ')}\"\n        ),\n      ];\n      \n      final response = await _model.generateContent(content);\n      final responseText = response.text;\n      \n      if (responseText == null) {\n        return [];\n      }\n      \n      // Parse the response into a list of recommendations\n      final recommendations = responseText\n          .split('\\n')\n          .where((line) => line.trim().isNotEmpty)\n          .toList();\n      \n      return recommendations;\n    } catch (e) {\n      print('Error getting job recommendations: $e');\n      return [];\n    }\n  }\n  \n  // Career recommendations using OpenAI API via Firebase Functions\n  Future<List<String>> getCareerRecommendations(User user) async {\n    try {\n      final result = await _functions.httpsCallable('getCareerRecommendations').call({\n        'classification': user.classification,\n        'careerGoals': user.careerGoals,\n        'isWorking': user.isWorking,\n      });\n      \n      final data = result.data as Map<String, dynamic>;\n      return List<String>.from(data['recommendations'] ?? []);\n    } catch (e) {\n      print('Error getting career recommendations: $e');\n      return [];\n    }\n  }\n  \n  // Wage trend analysis using Anthropic Claude API via Firebase Functions\n  Future<Map<String, dynamic>> getWageTrendAnalysis(String classification, List<String> locations) async {\n    try {\n      final result = await _functions.httpsCallable('getWageTrendAnalysis').call({\n        'classification': classification,\n        'locations': locations,\n      });\n      \n      return result.data as Map<String, dynamic>;\n    } catch (e) {\n      print('Error getting wage trend analysis: $e');\n      return {};\n    }\n  }\n}\n```\n\n2. Create Firebase Cloud Functions for OpenAI and Anthropic Claude API integration:\n\n```javascript\n// index.js (Firebase Functions)\nconst functions = require('firebase-functions');\nconst { OpenAI } = require('openai');\nconst { Anthropic } = require('@anthropic-ai/sdk');\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n\nconst anthropic = new Anthropic({\n  apiKey: process.env.ANTHROPIC_API_KEY,\n});\n\nexports.getCareerRecommendations = functions.https.onCall(async (data, context) => {\n  // Ensure user is authenticated\n  if (!context.auth) {\n    throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');\n  }\n  \n  const { classification, careerGoals, isWorking } = data;\n  \n  try {\n    const response = await openai.chat.completions.create({\n      model: 'gpt-4',\n      messages: [\n        {\n          role: 'system',\n          content: 'You are a career advisor for IBEW electrical workers. Provide specific, actionable career recommendations.'\n        },\n        {\n          role: 'user',\n          content: `I am an IBEW ${classification}. My career goals include ${Object.keys(careerGoals).filter(key => careerGoals[key]).join(', ')}. I am currently ${isWorking ? 'working' : 'not working'}. What career advancement steps should I consider?`\n        }\n      ],\n      max_tokens: 500,\n    });\n    \n    const recommendations = response.choices[0].message.content\n      .split('\\n')\n      .filter(line => line.trim().length > 0);\n    \n    return { recommendations };\n  } catch (error) {\n    console.error('OpenAI API error:', error);\n    throw new functions.https.HttpsError('internal', 'Error getting career recommendations');\n  }\n});\n\nexports.getWageTrendAnalysis = functions.https.onCall(async (data, context) => {\n  // Ensure user is authenticated\n  if (!context.auth) {\n    throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');\n  }\n  \n  const { classification, locations } = data;\n  \n  try {\n    const response = await anthropic.messages.create({\n      model: 'claude-3-opus-20240229',\n      max_tokens: 1000,\n      messages: [\n        {\n          role: 'user',\n          content: `Analyze wage trends for IBEW ${classification} in the following locations: ${locations.join(', ')}. Include current average wages, 5-year projections, and factors affecting wages. Format the response as JSON with the following structure: { \"currentAverage\": number, \"fiveYearProjection\": number, \"factors\": string[], \"locationComparisons\": { \"location1\": number, ... } }`\n        }\n      ],\n    });\n    \n    // Parse the JSON from the response\n    const content = response.content[0].text;\n    const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      return JSON.parse(jsonMatch[0]);\n    } else {\n      throw new Error('Failed to parse JSON from response');\n    }\n  } catch (error) {\n    console.error('Anthropic API error:', error);\n    throw new functions.https.HttpsError('internal', 'Error getting wage trend analysis');\n  }\n});\n```\n\n3. Create an AIRecommendationsScreen:\n\n```dart\nclass AIRecommendationsScreen extends StatefulWidget {\n  final User user;\n  \n  const AIRecommendationsScreen({required this.user});\n  \n  @override\n  _AIRecommendationsScreenState createState() => _AIRecommendationsScreenState();\n}\n\nclass _AIRecommendationsScreenState extends State<AIRecommendationsScreen> with SingleTickerProviderStateMixin {\n  final AIService _aiService = AIService();\n  late TabController _tabController;\n  \n  List<String> _jobRecommendations = [];\n  List<String> _careerRecommendations = [];\n  Map<String, dynamic> _wageTrendAnalysis = {};\n  \n  bool _isLoadingJobs = true;\n  bool _isLoadingCareer = true;\n  bool _isLoadingWage = true;\n  \n  @override\n  void initState() {\n    super.initState();\n    _tabController = TabController(length: 3, vsync: this);\n    _loadRecommendations();\n  }\n  \n  Future<void> _loadRecommendations() async {\n    // Load job recommendations\n    _aiService.getJobRecommendations(widget.user).then((recommendations) {\n      setState(() {\n        _jobRecommendations = recommendations;\n        _isLoadingJobs = false;\n      });\n    });\n    \n    // Load career recommendations\n    _aiService.getCareerRecommendations(widget.user).then((recommendations) {\n      setState(() {\n        _careerRecommendations = recommendations;\n        _isLoadingCareer = false;\n      });\n    });\n    \n    // Load wage trend analysis\n    final locations = [\n      widget.user.preferredLocal1,\n      widget.user.preferredLocal2,\n      widget.user.preferredLocal3,\n    ].where((local) => local > 0).map((local) => local.toString()).toList();\n    \n    if (locations.isNotEmpty) {\n      _aiService.getWageTrendAnalysis(widget.user.classification, locations).then((analysis) {\n        setState(() {\n          _wageTrendAnalysis = analysis;\n          _isLoadingWage = false;\n        });\n      });\n    } else {\n      setState(() {\n        _isLoadingWage = false;\n      });\n    }\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('AI Recommendations'),\n        bottom: TabBar(\n          controller: _tabController,\n          tabs: const [\n            Tab(text: 'Job Matches'),\n            Tab(text: 'Career Path'),\n            Tab(text: 'Wage Analysis'),\n          ],\n        ),\n      ),\n      body: TabBarView(\n        controller: _tabController,\n        children: [\n          _buildJobRecommendationsTab(),\n          _buildCareerRecommendationsTab(),\n          _buildWageTrendAnalysisTab(),\n        ],\n      ),\n    );\n  }\n  \n  Widget _buildJobRecommendationsTab() {\n    if (_isLoadingJobs) {\n      return const Center(child: CircularProgressIndicator());\n    }\n    \n    if (_jobRecommendations.isEmpty) {\n      return const Center(child: Text('No job recommendations available'));\n    }\n    \n    return ListView.builder(\n      padding: const EdgeInsets.all(16),\n      itemCount: _jobRecommendations.length,\n      itemBuilder: (context, index) {\n        return Card(\n          margin: const EdgeInsets.only(bottom: 16),\n          child: Padding(\n            padding: const EdgeInsets.all(16),\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                Row(\n                  children: [\n                    Icon(Icons.work, color: Theme.of(context).colorScheme.secondary),\n                    const SizedBox(width: 8),\n                    Text(\n                      'Recommendation ${index + 1}',\n                      style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16),\n                    ),\n                  ],\n                ),\n                const SizedBox(height: 8),\n                Text(_jobRecommendations[index]),\n              ],\n            ),\n          ),\n        );\n      },\n    );\n  }\n  \n  Widget _buildCareerRecommendationsTab() {\n    // Similar implementation to job recommendations tab\n  }\n  \n  Widget _buildWageTrendAnalysisTab() {\n    if (_isLoadingWage) {\n      return const Center(child: CircularProgressIndicator());\n    }\n    \n    if (_wageTrendAnalysis.isEmpty) {\n      return const Center(child: Text('No wage trend analysis available'));\n    }\n    \n    final currentAverage = _wageTrendAnalysis['currentAverage'];\n    final fiveYearProjection = _wageTrendAnalysis['fiveYearProjection'];\n    final factors = List<String>.from(_wageTrendAnalysis['factors'] ?? []);\n    final locationComparisons = _wageTrendAnalysis['locationComparisons'] as Map<String, dynamic>?;\n    \n    return SingleChildScrollView(\n      padding: const EdgeInsets.all(16),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          Card(\n            child: Padding(\n              padding: const EdgeInsets.all(16),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  const Text(\n                    'Wage Summary',\n                    style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),\n                  ),\n                  const SizedBox(height: 16),\n                  Row(\n                    mainAxisAlignment: MainAxisAlignment.spaceAround,\n                    children: [\n                      _buildWageInfoItem(\n                        'Current Average',\n                        '\\$${currentAverage.toStringAsFixed(2)}',\n                        Icons.attach_money,\n                      ),\n                      _buildWageInfoItem(\n                        '5-Year Projection',\n                        '\\$${fiveYearProjection.toStringAsFixed(2)}',\n                        Icons.trending_up,\n                      ),\n                    ],\n                  ),\n                ],\n              ),\n            ),\n          ),\n          const SizedBox(height: 16),\n          const Text(\n            'Factors Affecting Wages',\n            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),\n          ),\n          const SizedBox(height: 8),\n          Card(\n            child: Padding(\n              padding: const EdgeInsets.all(16),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: factors.map((factor) {\n                  return Padding(\n                    padding: const EdgeInsets.symmetric(vertical: 4),\n                    child: Row(\n                      crossAxisAlignment: CrossAxisAlignment.start,\n                      children: [\n                        const Text(' ', style: TextStyle(fontSize: 16)),\n                        Expanded(child: Text(factor)),\n                      ],\n                    ),\n                  );\n                }).toList(),\n              ),\n            ),\n          ),\n          if (locationComparisons != null && locationComparisons.isNotEmpty) ...[  \n            const SizedBox(height: 16),\n            const Text(\n              'Location Comparison',\n              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 8),\n            Card(\n              child: Padding(\n                padding: const EdgeInsets.all(16),\n                child: Column(\n                  children: locationComparisons.entries.map((entry) {\n                    return Padding(\n                      padding: const EdgeInsets.symmetric(vertical: 8),\n                      child: Row(\n                        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                        children: [\n                          Text('Local ${entry.key}'),\n                          Text(\n                            '\\$${entry.value.toStringAsFixed(2)}',\n                            style: const TextStyle(fontWeight: FontWeight.bold),\n                          ),\n                        ],\n                      ),\n                    );\n                  }).toList(),\n                ),\n              ),\n            ),\n          ],\n        ],\n      ),\n    );\n  }\n  \n  Widget _buildWageInfoItem(String label, String value, IconData icon) {\n    return Column(\n      children: [\n        Icon(icon, size: 40, color: Theme.of(context).colorScheme.secondary),\n        const SizedBox(height: 8),\n        Text(label, style: const TextStyle(fontSize: 14, color: Colors.grey)),\n        const SizedBox(height: 4),\n        Text(\n          value,\n          style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n        ),\n      ],\n    );\n  }\n}\n```",
        "testStrategy": "1. Test API integration with Google Generative AI\n2. Verify Firebase Functions deployment and execution\n3. Test OpenAI API integration via Firebase Functions\n4. Validate Anthropic Claude API integration via Firebase Functions\n5. Test error handling for API failures\n6. Verify UI rendering of AI recommendations\n7. Test performance and response times\n8. Validate data parsing from API responses\n9. Test with various user profiles to ensure recommendations are relevant",
        "priority": "medium",
        "dependencies": [
          2,
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Firebase Functions Setup for API Proxying",
            "description": "Set up Firebase Cloud Functions to securely proxy API requests to various AI services, protecting API keys from client exposure.",
            "dependencies": [],
            "details": "Create a Firebase Functions project, implement secure authentication, set up environment variables for API keys, and create proxy endpoints for each AI service (Google Generative AI, OpenAI, Anthropic Claude). Include error handling and rate limiting.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Google Generative AI Integration for Job Matching",
            "description": "Implement integration with Google's Generative AI to analyze user profiles and match them with suitable job opportunities.",
            "dependencies": [
              1
            ],
            "details": "Create a service that formats user profile data, sends it to the Google Generative AI API via Firebase Functions, processes the response, and stores the job matches. Include prompt engineering for optimal results and fallback mechanisms for API failures.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "OpenAI Integration for Career Recommendations",
            "description": "Integrate OpenAI's API to generate personalized career path recommendations based on user skills, experience, and goals.",
            "dependencies": [
              1
            ],
            "details": "Develop a service to prepare user data for OpenAI, send requests through Firebase Functions, parse and validate responses, and format career path recommendations. Implement caching to reduce API calls and costs.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Anthropic Claude Integration for Wage Analysis",
            "description": "Implement Anthropic Claude API integration to analyze wage trends and provide salary insights based on job titles, locations, and experience levels.",
            "dependencies": [
              1
            ],
            "details": "Create a service to gather relevant wage data, format requests to Anthropic Claude via Firebase Functions, process responses, and prepare data for visualization. Include mechanisms to handle API limitations and ensure data accuracy.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "AI Recommendations Screen with Tabbed Interface",
            "description": "Develop the main AI recommendations screen with a tabbed interface to navigate between different types of AI-powered insights.",
            "dependencies": [],
            "details": "Create a responsive screen layout with tabs for job matches, career recommendations, and wage analysis. Implement tab navigation, loading states, error handling, and a consistent design that follows the app's style guide.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Job Recommendations UI Implementation",
            "description": "Build the UI components to display job matches generated by Google Generative AI in a user-friendly format.",
            "dependencies": [
              2,
              5
            ],
            "details": "Develop list and card components to display job matches, including job titles, companies, match scores, and key requirements. Add filtering options, sorting capabilities, and the ability to save or apply to jobs directly from recommendations.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Career Path Recommendations UI",
            "description": "Implement UI components to visualize career path recommendations from OpenAI in an engaging and actionable format.",
            "dependencies": [
              3,
              5
            ],
            "details": "Create interactive career path visualizations showing progression steps, required skills, and estimated timelines. Include detailed information panels for each career stage and actionable next steps for users to pursue recommended paths.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Wage Trend Analysis Visualization",
            "description": "Develop data visualization components to present wage analysis insights from Anthropic Claude in an informative and interactive way.",
            "dependencies": [
              4,
              5
            ],
            "details": "Implement charts and graphs (bar charts, line graphs, heat maps) to visualize wage trends by location, experience level, and industry. Add interactive elements allowing users to filter data, compare different factors, and view personalized salary recommendations.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Offline Capability and Data Synchronization",
        "description": "Develop offline capability for critical features and implement data synchronization to ensure a seamless user experience with or without internet connectivity.",
        "details": "1. Configure Firestore for offline persistence:\n\n```dart\n// In main.dart or app initialization\nFirebaseFirestore.instance.settings = Settings(\n  persistenceEnabled: true,\n  cacheSizeBytes: Settings.CACHE_SIZE_UNLIMITED,\n);\n```\n\n2. Create a NetworkService to monitor connectivity:\n\n```dart\nclass NetworkService {\n  final Connectivity _connectivity = Connectivity();\n  final BehaviorSubject<bool> _connectionStatus = BehaviorSubject<bool>.seeded(true);\n  \n  NetworkService() {\n    _initConnectivity();\n    _connectivity.onConnectivityChanged.listen(_updateConnectionStatus);\n  }\n  \n  Stream<bool> get connectionStatus => _connectionStatus.stream;\n  bool get isConnected => _connectionStatus.value;\n  \n  Future<void> _initConnectivity() async {\n    try {\n      final result = await _connectivity.checkConnectivity();\n      _updateConnectionStatus(result);\n    } catch (e) {\n      _connectionStatus.add(false);\n    }\n  }\n  \n  void _updateConnectionStatus(ConnectivityResult result) {\n    _connectionStatus.add(result != ConnectivityResult.none);\n  }\n  \n  void dispose() {\n    _connectionStatus.close();\n  }\n}\n```\n\n3. Create a CacheManager for local storage of critical data:\n\n```dart\nclass CacheManager {\n  final SharedPreferences _prefs;\n  \n  CacheManager(this._prefs);\n  \n  static Future<CacheManager> getInstance() async {\n    final prefs = await SharedPreferences.getInstance();\n    return CacheManager(prefs);\n  }\n  \n  // Cache jobs data\n  Future<void> cacheJobs(List<Job> jobs) async {\n    final jobsJson = jobs.map((job) => job.toJson()).toList();\n    await _prefs.setString('cached_jobs', jsonEncode(jobsJson));\n    await _prefs.setInt('jobs_cache_timestamp', DateTime.now().millisecondsSinceEpoch);\n  }\n  \n  List<Job>? getCachedJobs() {\n    final jobsString = _prefs.getString('cached_jobs');\n    if (jobsString == null) return null;\n    \n    try {\n      final jobsJson = jsonDecode(jobsString) as List;\n      return jobsJson.map((json) => Job.fromJson(json)).toList();\n    } catch (e) {\n      print('Error parsing cached jobs: $e');\n      return null;\n    }\n  }\n  \n  // Cache locals data\n  Future<void> cacheLocals(List<Local> locals) async {\n    final localsJson = locals.map((local) => local.toJson()).toList();\n    await _prefs.setString('cached_locals', jsonEncode(localsJson));\n    await _prefs.setInt('locals_cache_timestamp', DateTime.now().millisecondsSinceEpoch);\n  }\n  \n  List<Local>? getCachedLocals() {\n    final localsString = _prefs.getString('cached_locals');\n    if (localsString == null) return null;\n    \n    try {\n      final localsJson = jsonDecode(localsString) as List;\n      return localsJson.map((json) => Local.fromJson(json)).toList();\n    } catch (e) {\n      print('Error parsing cached locals: $e');\n      return null;\n    }\n  }\n  \n  // Cache user profile\n  Future<void> cacheUserProfile(User user) async {\n    await _prefs.setString('cached_user_profile', jsonEncode(user.toJson()));\n    await _prefs.setInt('user_profile_cache_timestamp', DateTime.now().millisecondsSinceEpoch);\n  }\n  \n  User? getCachedUserProfile() {\n    final userString = _prefs.getString('cached_user_profile');\n    if (userString == null) return null;\n    \n    try {\n      final userJson = jsonDecode(userString);\n      return User.fromJson(userJson);\n    } catch (e) {\n      print('Error parsing cached user profile: $e');\n      return null;\n    }\n  }\n  \n  // Check if cache is expired\n  bool isCacheExpired(String key, {int expirationHours = 24}) {\n    final timestampKey = '${key}_cache_timestamp';\n    final timestamp = _prefs.getInt(timestampKey);\n    if (timestamp == null) return true;\n    \n    final cacheTime = DateTime.fromMillisecondsSinceEpoch(timestamp);\n    final now = DateTime.now();\n    return now.difference(cacheTime).inHours > expirationHours;\n  }\n  \n  // Clear all caches\n  Future<void> clearAllCaches() async {\n    await _prefs.remove('cached_jobs');\n    await _prefs.remove('jobs_cache_timestamp');\n    await _prefs.remove('cached_locals');\n    await _prefs.remove('locals_cache_timestamp');\n    await _prefs.remove('cached_user_profile');\n    await _prefs.remove('user_profile_cache_timestamp');\n  }\n}\n```\n\n4. Update repository implementations to support offline mode:\n\n```dart\nclass FirebaseJobRepository implements JobRepository {\n  final FirebaseFirestore _firestore = FirebaseFirestore.instance;\n  final NetworkService _networkService = NetworkService();\n  late CacheManager _cacheManager;\n  \n  FirebaseJobRepository() {\n    _initCacheManager();\n  }\n  \n  Future<void> _initCacheManager() async {\n    _cacheManager = await CacheManager.getInstance();\n  }\n  \n  @override\n  Stream<List<Job>> getJobs() {\n    // Create a stream controller to manage the data flow\n    final controller = StreamController<List<Job>>();\n    \n    // Check network status\n    if (_networkService.isConnected) {\n      // If online, get data from Firestore\n      final firestoreStream = _firestore.collection('jobs')\n          .orderBy('timestamp', descending: true)\n          .snapshots()\n          .map((snapshot) {\n        final jobs = snapshot.docs\n            .map((doc) => Job.fromJson(doc.data()))\n            .toList();\n        \n        // Cache the jobs for offline use\n        _cacheManager.cacheJobs(jobs);\n        \n        return jobs;\n      });\n      \n      // Add the Firestore stream to the controller\n      firestoreStream.listen(\n        (jobs) => controller.add(jobs),\n        onError: (error) => controller.addError(error),\n        onDone: () => controller.close(),\n      );\n    } else {\n      // If offline, get data from cache\n      final cachedJobs = _cacheManager.getCachedJobs();\n      if (cachedJobs != null) {\n        controller.add(cachedJobs);\n      } else {\n        controller.add([]);\n      }\n    }\n    \n    return controller.stream;\n  }\n  \n  // Similar implementation for other methods\n}\n\n// Similar updates for UserRepository and LocalRepository\n```\n\n5. Create a SyncService to handle data synchronization when coming back online:\n\n```dart\nclass SyncService {\n  final NetworkService _networkService;\n  final CacheManager _cacheManager;\n  final JobRepository _jobRepository;\n  final UserRepository _userRepository;\n  final LocalRepository _localRepository;\n  \n  SyncService({\n    required NetworkService networkService,\n    required CacheManager cacheManager,\n    required JobRepository jobRepository,\n    required UserRepository userRepository,\n    required LocalRepository localRepository,\n  }) : _networkService = networkService,\n       _cacheManager = cacheManager,\n       _jobRepository = jobRepository,\n       _userRepository = userRepository,\n       _localRepository = localRepository {\n    _init();\n  }\n  \n  void _init() {\n    _networkService.connectionStatus.listen((isConnected) {\n      if (isConnected) {\n        _syncData();\n      }\n    });\n  }\n  \n  Future<void> _syncData() async {\n    // Sync pending user updates\n    final pendingUserUpdates = await _getPendingUserUpdates();\n    if (pendingUserUpdates.isNotEmpty) {\n      await _syncUserUpdates(pendingUserUpdates);\n    }\n    \n    // Refresh cached data if expired\n    if (_cacheManager.isCacheExpired('jobs')) {\n      _refreshJobsCache();\n    }\n    \n    if (_cacheManager.isCacheExpired('locals')) {\n      _refreshLocalsCache();\n    }\n  }\n  \n  Future<List<Map<String, dynamic>>> _getPendingUserUpdates() async {\n    // Implementation to get pending user updates from local storage\n  }\n  \n  Future<void> _syncUserUpdates(List<Map<String, dynamic>> updates) async {\n    // Implementation to sync pending user updates to Firestore\n  }\n  \n  Future<void> _refreshJobsCache() async {\n    // Implementation to refresh jobs cache\n  }\n  \n  Future<void> _refreshLocalsCache() async {\n    // Implementation to refresh locals cache\n  }\n}\n```\n\n6. Update the UI to show offline status and handle offline interactions:\n\n```dart\nclass OfflineIndicator extends StatelessWidget {\n  final NetworkService _networkService;\n  \n  OfflineIndicator({required NetworkService networkService})\n      : _networkService = networkService;\n  \n  @override\n  Widget build(BuildContext context) {\n    return StreamBuilder<bool>(\n      stream: _networkService.connectionStatus,\n      builder: (context, snapshot) {\n        final isConnected = snapshot.data ?? true;\n        \n        if (isConnected) {\n          return const SizedBox.shrink();\n        }\n        \n        return Container(\n          color: Colors.red,\n          padding: const EdgeInsets.symmetric(vertical: 4),\n          child: const Center(\n            child: Text(\n              'You are offline. Some features may be limited.',\n              style: TextStyle(color: Colors.white),\n            ),\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\n7. Add the offline indicator to the main app scaffold:\n\n```dart\nclass MainApp extends StatefulWidget {\n  @override\n  _MainAppState createState() => _MainAppState();\n}\n\nclass _MainAppState extends State<MainApp> {\n  final NetworkService _networkService = NetworkService();\n  late SyncService _syncService;\n  \n  @override\n  void initState() {\n    super.initState();\n    _initSyncService();\n  }\n  \n  Future<void> _initSyncService() async {\n    final cacheManager = await CacheManager.getInstance();\n    _syncService = SyncService(\n      networkService: _networkService,\n      cacheManager: cacheManager,\n      jobRepository: FirebaseJobRepository(),\n      userRepository: FirebaseUserRepository(),\n      localRepository: FirebaseLocalRepository(),\n    );\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Column(\n        children: [\n          OfflineIndicator(networkService: _networkService),\n          Expanded(\n            child: _screens[_currentIndex],\n          ),\n        ],\n      ),\n      bottomNavigationBar: BottomNavigationBar(\n        // Bottom navigation implementation\n      ),\n    );\n  }\n}\n```",
        "testStrategy": "1. Test Firestore offline persistence configuration\n2. Verify data caching functionality\n3. Test network status detection\n4. Validate data synchronization when coming back online\n5. Test UI behavior in offline mode\n6. Verify cache expiration logic\n7. Test with various network conditions (slow, intermittent, etc.)\n8. Validate data integrity after synchronization\n9. Test memory usage and performance with large cached datasets",
        "priority": "medium",
        "dependencies": [
          2,
          5,
          6,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Firestore Offline Persistence",
            "description": "Set up Firestore to enable offline data persistence and configure cache size limits",
            "dependencies": [],
            "details": "Implement Firestore offline persistence configuration by enabling the persistenceEnabled flag. Set appropriate cache size limits based on expected data volume. Configure synchronization settings for when the app returns online. Test that data remains accessible when the device is offline.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create Network Connectivity Monitoring Service",
            "description": "Develop a service to detect and track network connectivity status changes",
            "dependencies": [],
            "details": "Create a NetworkMonitorService that uses platform-specific APIs to detect connectivity status. Implement a reactive stream (BehaviorSubject) that components can subscribe to for real-time network status. Add methods to check current connectivity and register for network state changes. Include unit tests for different connectivity scenarios.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Local Data Caching System",
            "description": "Build a local storage system to cache application data for offline access",
            "dependencies": [
              1
            ],
            "details": "Implement a local caching layer using IndexedDB or similar storage mechanism. Create data models for cached entities with timestamps for synchronization. Develop CRUD operations for the cache that mirror the online operations. Ensure data is properly encrypted if sensitive. Add cache expiration and cleanup mechanisms.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Adapt Repositories for Offline Support",
            "description": "Modify existing repository classes to support offline operations and data access",
            "dependencies": [
              1,
              3
            ],
            "details": "Update repository classes to first attempt online operations, then fall back to cached data when offline. Implement queuing system for write operations performed while offline. Add transaction support to ensure data consistency. Create methods to differentiate between fresh and cached data. Update unit tests to cover offline scenarios.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Develop Data Synchronization Service",
            "description": "Create a service to synchronize local and remote data when connectivity is restored",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement a SyncService that triggers when network connectivity is restored. Create logic to upload pending changes from the local queue to Firestore. Develop mechanisms to fetch and merge remote changes that occurred while offline. Add retry logic for failed synchronization attempts. Include logging for synchronization events and errors.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement Offline UI Indicators and User Experience",
            "description": "Add UI components to indicate offline status and manage user expectations",
            "dependencies": [
              2
            ],
            "details": "Create UI indicators showing current connectivity status. Implement toast notifications for connection changes. Add visual differentiation for cached vs. fresh data. Design feedback for queued operations that will execute when online. Ensure all critical functions have appropriate offline fallbacks. Test user experience in various connectivity scenarios.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Develop Conflict Resolution Strategy",
            "description": "Implement logic to handle data conflicts between local and remote changes",
            "dependencies": [
              5
            ],
            "details": "Create conflict detection by comparing timestamps and version numbers. Implement automatic resolution strategies for non-critical conflicts. Design UI for manual conflict resolution when necessary. Add transaction logs to track changes for auditing and debugging. Test conflict scenarios thoroughly with various data types and change patterns.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement Analytics, Error Reporting, and Performance Monitoring",
        "description": "Integrate Firebase Analytics, Crashlytics, and Performance Monitoring to track user behavior, report errors, and monitor app performance.",
        "details": "1. Add the required dependencies to pubspec.yaml:\n\n```yaml\ndependencies:\n  firebase_analytics: ^10.4.4\n  firebase_crashlytics: ^3.3.4\n  firebase_performance: ^0.9.2+4\n```\n\n2. Initialize Firebase services in main.dart:\n\n```dart\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await Firebase.initializeApp(\n    options: DefaultFirebaseOptions.currentPlatform,\n  );\n  \n  // Initialize Crashlytics\n  await FirebaseCrashlytics.instance.setCrashlyticsCollectionEnabled(true);\n  FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterError;\n  \n  // Initialize Performance Monitoring\n  await FirebasePerformance.instance.setPerformanceCollectionEnabled(true);\n  \n  runApp(MyApp());\n}\n```\n\n3. Create an AnalyticsService to track user events:\n\n```dart\nclass AnalyticsService {\n  final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;\n  \n  // Log screen views\n  Future<void> logScreenView(String screenName) async {\n    await _analytics.logScreenView(screenName: screenName);\n  }\n  \n  // Log job view\n  Future<void> logJobView(String jobId, int localNumber) async {\n    await _analytics.logEvent(\n      name: 'job_view',\n      parameters: {\n        'job_id': jobId,\n        'local_number': localNumber,\n      },\n    );\n  }\n  \n  // Log local view\n  Future<void> logLocalView(String localNumber) async {\n    await _analytics.logEvent(\n      name: 'local_view',\n      parameters: {\n        'local_number': localNumber,\n      },\n    );\n  }\n  \n  // Log job application\n  Future<void> logJobApplication(String jobId, int localNumber) async {\n    await _analytics.logEvent(\n      name: 'job_application',\n      parameters: {\n        'job_id': jobId,\n        'local_number': localNumber,\n      },\n    );\n  }\n  \n  // Log search\n  Future<void> logSearch(String searchTerm, String searchType) async {\n    await _analytics.logSearch(searchTerm: searchTerm);\n    await _analytics.logEvent(\n      name: 'custom_search',\n      parameters: {\n        'search_term': searchTerm,\n        'search_type': searchType,\n      },\n    );\n  }\n  \n  // Log filter use\n  Future<void> logFilterUse(Map<String, dynamic> filters) async {\n    await _analytics.logEvent(\n      name: 'filter_use',\n      parameters: {\n        'filters': filters.toString(),\n      },\n    );\n  }\n  \n  // Log user properties\n  Future<void> setUserProperties(User user) async {\n    await _analytics.setUserProperty(\n      name: 'home_local',\n      value: user.homeLocal.toString(),\n    );\n    await _analytics.setUserProperty(\n      name: 'classification',\n      value: user.classification,\n    );\n    await _analytics.setUserProperty(\n      name: 'is_working',\n      value: user.isWorking.toString(),\n    );\n  }\n}\n```\n\n4. Create an ErrorReportingService to handle error reporting:\n\n```dart\nclass ErrorReportingService {\n  final FirebaseCrashlytics _crashlytics = FirebaseCrashlytics.instance;\n  \n  // Log non-fatal error\n  Future<void> logError(dynamic error, StackTrace stackTrace) async {\n    await _crashlytics.recordError(error, stackTrace, fatal: false);\n  }\n  \n  // Set user identifier for error reports\n  Future<void> setUserIdentifier(String userId) async {\n    await _crashlytics.setUserIdentifier(userId);\n  }\n  \n  // Add custom keys for error context\n  Future<void> setCustomKey(String key, dynamic value) async {\n    await _crashlytics.setCustomKey(key, value);\n  }\n  \n  // Log custom message\n  Future<void> log(String message) async {\n    await _crashlytics.log(message);\n  }\n}\n```\n\n5. Create a PerformanceMonitoringService to track performance metrics:\n\n```dart\nclass PerformanceMonitoringService {\n  final FirebasePerformance _performance = FirebasePerformance.instance;\n  \n  // Track HTTP request performance\n  HttpMetric startHttpMetric(String url, String method) {\n    final metric = _performance.newHttpMetric(url, HttpMethod.values.firstWhere(\n      (m) => m.toString().split('.').last.toUpperCase() == method.toUpperCase(),\n      orElse: () => HttpMethod.get,\n    ));\n    metric.start();\n    return metric;\n  }\n  \n  // Track custom trace performance\n  Trace startTrace(String name) {\n    final trace = _performance.newTrace(name);\n    trace.start();\n    return trace;\n  }\n}\n```\n\n6. Create a ServiceProvider to provide access to all services:\n\n```dart\nclass ServiceProvider extends InheritedWidget {\n  final AnalyticsService analyticsService;\n  final ErrorReportingService errorReportingService;\n  final PerformanceMonitoringService performanceMonitoringService;\n  \n  const ServiceProvider({\n    Key? key,\n    required Widget child,\n    required this.analyticsService,\n    required this.errorReportingService,\n    required this.performanceMonitoringService,\n  }) : super(key: key, child: child);\n  \n  static ServiceProvider of(BuildContext context) {\n    final ServiceProvider? result = context.dependOnInheritedWidgetOfExactType<ServiceProvider>();\n    assert(result != null, 'No ServiceProvider found in context');\n    return result!;\n  }\n  \n  @override\n  bool updateShouldNotify(ServiceProvider oldWidget) {\n    return false;\n  }\n}\n```\n\n7. Integrate analytics tracking in screens:\n\n```dart\nclass JobsScreen extends StatefulWidget {\n  @override\n  _JobsScreenState createState() => _JobsScreenState();\n}\n\nclass _JobsScreenState extends State<JobsScreen> {\n  @override\n  void initState() {\n    super.initState();\n    // Log screen view\n    ServiceProvider.of(context).analyticsService.logScreenView('jobs_screen');\n  }\n  \n  void _navigateToJobDetails(Job job) {\n    // Log job view\n    ServiceProvider.of(context).analyticsService.logJobView(\n      job.id,\n      job.local,\n    );\n    \n    // Navigate to job details\n    Navigator.push(\n      context,\n      MaterialPageRoute(\n        builder: (context) => JobDetailsScreen(job: job),\n      ),\n    );\n  }\n  \n  // Rest of the implementation\n}\n```\n\n8. Integrate performance monitoring for critical operations:\n\n```dart\nclass FirebaseJobRepository implements JobRepository {\n  final FirebaseFirestore _firestore = FirebaseFirestore.instance;\n  final PerformanceMonitoringService _performanceService;\n  \n  FirebaseJobRepository(this._performanceService);\n  \n  @override\n  Future<List<Job>> getFilteredJobs(Map<String, dynamic> filters) async {\n    // Start performance trace\n    final trace = _performanceService.startTrace('get_filtered_jobs');\n    trace.putAttribute('filter_count', filters.length.toString());\n    \n    try {\n      // Build query based on filters\n      Query query = _firestore.collection('jobs');\n      \n      // Apply filters\n      filters.forEach((key, value) {\n        if (value != null) {\n          query = query.where(key, isEqualTo: value);\n        }\n      });\n      \n      // Execute query\n      final snapshot = await query.get();\n      \n      // Parse results\n      final jobs = snapshot.docs\n          .map((doc) => Job.fromJson(doc.data()))\n          .toList();\n      \n      // Stop trace\n      trace.putAttribute('result_count', jobs.length.toString());\n      await trace.stop();\n      \n      return jobs;\n    } catch (e, stackTrace) {\n      // Log error\n      ServiceProvider.of(context).errorReportingService.logError(e, stackTrace);\n      \n      // Stop trace with error\n      trace.putAttribute('error', e.toString());\n      await trace.stop();\n      \n      rethrow;\n    }\n  }\n  \n  // Rest of the implementation\n}\n```\n\n9. Add global error handling:\n\n```dart\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ServiceProvider(\n      analyticsService: AnalyticsService(),\n      errorReportingService: ErrorReportingService(),\n      performanceMonitoringService: PerformanceMonitoringService(),\n      child: MaterialApp(\n        title: 'Journeyman Jobs',\n        theme: AppTheme.lightTheme,\n        navigatorObservers: [\n          FirebaseAnalyticsObserver(analytics: FirebaseAnalytics.instance),\n        ],\n        builder: (context, child) {\n          // Add error boundary\n          return ErrorBoundary(child: child!);\n        },\n        home: SplashScreen(),\n      ),\n    );\n  }\n}\n\nclass ErrorBoundary extends StatefulWidget {\n  final Widget child;\n  \n  const ErrorBoundary({required this.child});\n  \n  @override\n  _ErrorBoundaryState createState() => _ErrorBoundaryState();\n}\n\nclass _ErrorBoundaryState extends State<ErrorBoundary> {\n  bool _hasError = false;\n  \n  @override\n  void initState() {\n    super.initState();\n    FlutterError.onError = (details) {\n      FirebaseCrashlytics.instance.recordFlutterError(details);\n      setState(() {\n        _hasError = true;\n      });\n    };\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    if (_hasError) {\n      return Scaffold(\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              const Icon(Icons.error_outline, size: 64, color: Colors.red),\n              const SizedBox(height: 16),\n              const Text(\n                'Something went wrong',\n                style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n              ),\n              const SizedBox(height: 8),\n              const Text(\n                'The app encountered an error. Please try again.',\n                textAlign: TextAlign.center,\n              ),\n              const SizedBox(height: 24),\n              ElevatedButton(\n                onPressed: () {\n                  setState(() {\n                    _hasError = false;\n                  });\n                },\n                child: const Text('Try Again'),\n              ),\n            ],\n          ),\n        ),\n      );\n    }\n    \n    return widget.child;\n  }\n}\n```",
        "testStrategy": "1. Verify Firebase Analytics integration by testing event logging\n2. Test Crashlytics by triggering test exceptions\n3. Validate Performance Monitoring traces and HTTP metrics\n4. Test error boundary functionality with simulated errors\n5. Verify custom analytics events are properly tracked\n6. Test user property setting\n7. Validate performance metrics collection for critical operations\n8. Test error reporting with different error types\n9. Verify analytics data appears in Firebase console\n10. Test performance monitoring with slow network conditions",
        "priority": "low",
        "dependencies": [
          1,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Firebase Analytics Integration",
            "description": "Implement Firebase Analytics and set up custom event tracking throughout the application",
            "dependencies": [],
            "details": "1. Add Firebase Analytics dependencies to the project\n2. Initialize Firebase Analytics in the application\n3. Define key user actions and screens to track\n4. Create an analytics service with methods for tracking standard events\n5. Implement custom event tracking with parameters\n6. Add analytics tracking to main user flows\n7. Test event logging and verify in Firebase console",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Crashlytics Setup and Error Reporting",
            "description": "Implement Firebase Crashlytics and create an error reporting service",
            "dependencies": [
              1
            ],
            "details": "1. Add Crashlytics dependencies to the project\n2. Initialize Crashlytics in the application\n3. Create an error reporting service with methods for logging exceptions\n4. Implement custom keys and logs for better crash context\n5. Set up non-fatal error reporting\n6. Configure ProGuard rules for proper stack traces\n7. Test crash reporting and verify in Firebase console",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Performance Monitoring Implementation",
            "description": "Set up Firebase Performance Monitoring for critical app operations",
            "dependencies": [
              1
            ],
            "details": "1. Add Performance Monitoring dependencies\n2. Initialize Performance Monitoring in the application\n3. Identify critical operations to monitor (API calls, image loading, etc.)\n4. Implement trace tracking for key user flows\n5. Add custom metrics to traces where needed\n6. Create performance monitoring utilities for common operations\n7. Test performance traces and verify in Firebase console",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Global Error Handling and UI",
            "description": "Implement global error handling with appropriate UI feedback",
            "dependencies": [
              2
            ],
            "details": "1. Create a global exception handler\n2. Design error UI components (dialogs, snackbars, etc.)\n3. Categorize errors by type (network, server, client, etc.)\n4. Implement appropriate UI responses for different error types\n5. Add retry mechanisms where appropriate\n6. Create graceful degradation strategies\n7. Test error handling across different scenarios",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Monitoring Service Provider",
            "description": "Create a service provider for dependency injection of all monitoring services",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "1. Design a monitoring service provider interface\n2. Implement concrete provider with all monitoring services\n3. Set up dependency injection for the monitoring services\n4. Create configuration options for different environments\n5. Add logging toggles for debug/release builds\n6. Document usage patterns for the team\n7. Create sample implementations for common scenarios",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-04T19:18:20.026Z",
      "updated": "2025-07-04T19:18:20.027Z",
      "description": "Tasks for master context"
    }
  }
}